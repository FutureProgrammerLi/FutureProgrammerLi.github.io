<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Future Li">
  <!-- Open Graph Data -->
  <meta property="og:title" content="LeetCode"/>
  <meta property="og:description" content="What is this?" />
  <meta property="og:site_name" content="Hello!"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="Hello!" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Hello!</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">LeetCode</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/FutureProgrammerLi" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:617612567@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Future Li</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-10-19</span>
            <span class="time">12:22:57</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <blockquote>
<p>每天一题简单算法题吧，不知能坚持多久。But , small changes count :) </p>
</blockquote>
<h3><span id="1比较含退格的字符串">1.比较含退格的字符串</span></h3><blockquote>
<p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路： 一开始我找井号的索引，然后连续删除这个索引及之前的两个数。发现过不了’ab##’这个测试用例。之后用<strong>栈</strong>，遇到井号就弹出，不是则推到另外的数组里面，返回数组的join(‘’)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPound</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> strArr = str.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> stack = [];  <span class="comment">//新建一个栈，就不怕pop,push影响原来的字符串数组了。</span></span><br><span class="line">    strArr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        item === <span class="string">'#'</span> ? stack.pop() : stack.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> stack.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> backspaceCompare = <span class="function"><span class="keyword">function</span> (<span class="params">S,T</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findPound(S) === findPound(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2一维数组的动态和">2.一维数组的动态和</span></h3><blockquote>
<p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</p>
<p>请返回 nums 的动态和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路: 求和第一反应就想到reduce, 不过里面逻辑应该可以优化.我的做法是根据当前索引,如果索引大于等于0,就将对应索引的值相加,之后索引值减1,直到索引值为0.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runningSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result = nums.reduce(<span class="function">(<span class="params">acc,cur,index,whole</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> sum = <span class="number">0</span>;  <span class="comment">//结果数组的每一项</span></span><br><span class="line">       <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           sum = sum + whole[index]; </span><br><span class="line">           index--;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">//如索引index为2,以上逻辑就是nums[2]+nums[1]+nums[0];到index===-1时跳出循环</span></span><br><span class="line">       acc.push(sum);</span><br><span class="line">       <span class="keyword">return</span> acc;</span><br><span class="line">   &#125;,[]);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//40%</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单实现</span></span><br><span class="line"><span class="keyword">var</span> runningSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = nums[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：shou-wang-20</span></span><br><span class="line"><span class="comment">//来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">//思路:从数组第二项开始,结果的下一项是前一项和当前项的和.</span></span><br><span class="line"><span class="comment">//95%</span></span><br></pre></td></tr></table></figure>

<h3><span id="3字符串左旋转">3.字符串左旋转</span></h3><blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路: 围绕字符串的slice,substr, substring方法,结合实现.根据k截取前k位和后面部分,再拼接即可.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.substr(n,s.length) + s.slice(<span class="number">0</span>,n);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//substr(from,length)</span></span><br><span class="line"><span class="comment">//substring(start,end)</span></span><br><span class="line"><span class="comment">//slice(start,end)</span></span><br><span class="line"><span class="comment">//64%</span></span><br></pre></td></tr></table></figure>

<h3><span id="4好数对的数目">4.好数对的数目</span></h3><blockquote>
<p>给你一个整数数组 nums 。</p>
<p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。</p>
<p>返回好数对的数目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1,1,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路： 两个索引,i和j。i代表当前，j代表i之后的所有。i逐渐右移，变大，j扫描次数（对比次数）逐渐缩小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numIdenticalPairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;= nums.length - <span class="number">2</span>; i++)&#123;  <span class="comment">//注意这里的等号。nums[nums.length-1]是最后一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= nums.length <span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] === nums[j])&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//60%</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表解法，元素只是作为属性名，结果依赖属性值。</span></span><br><span class="line"><span class="keyword">var</span> numIdenticalPairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, map = &#123;&#125;;</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(map[num])&#123;    <span class="comment">//已经出现过的元素</span></span><br><span class="line">           count += map[num];   <span class="comment">//累计和, 1+2+3+4 ...</span></span><br><span class="line">           map[num]++;          <span class="comment">//出现次数+1(?)</span></span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           map[num] = <span class="number">1</span>;  <span class="comment">//第一次扫描到的元素</span></span><br><span class="line">       &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表统计元素出现次数?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countTimes</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = arr.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(cur <span class="keyword">in</span> acc)&#123;</span><br><span class="line">           acc[cur]++;</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           acc[cur] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5拥有最多糖果的孩子">5.拥有最多糖果的孩子</span></h3><blockquote>
<p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：candies &#x3D; [2,3,5,1,3], extraCandies &#x3D; 3</span><br><span class="line">输出：[true,true,true,false,true] </span><br><span class="line">解释：</span><br><span class="line">孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：找出数组的最大值；遍历数组，单项的值加上所有的extracandies大于等于最大值的话，返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kidsWithCandies = <span class="function"><span class="keyword">function</span>(<span class="params">candies, extraCandies</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...candies);</span><br><span class="line">    <span class="keyword">let</span> result = candies.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        cur + extraCandies &gt;= max? acc.push(<span class="literal">true</span>) : acc.push(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,[]);</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接map</span></span><br><span class="line"><span class="comment">//return candies.map(item=&gt;item + extraCandies &gt;= max );</span></span><br></pre></td></tr></table></figure>

<h3><span id="6重排数组">6.重排数组</span></h3><blockquote>
<p>给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。</p>
<p>请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,1,3,4,7], n &#x3D; 3</span><br><span class="line">输出：[2,3,5,4,1,7] </span><br><span class="line">解释：由于 x1&#x3D;2, x2&#x3D;5, x3&#x3D;1, y1&#x3D;3, y2&#x3D;4, y3&#x3D;7 ，所以答案为 [2,3,5,4,1,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：毫无效率的暴力算法。2n个数要执行n次。新数组, push索引为0 ,n , 1, n+1 ,2,n+2的值..</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shuffle = <span class="function"><span class="keyword">function</span>(<span class="params">nums, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> j = n + i;</span><br><span class="line">        result.push(nums[i],nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//64%</span></span><br></pre></td></tr></table></figure>

<h3><span id="7删除中间节点">7.删除中间节点</span></h3><blockquote>
<p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：只能访问被删除的节点。将当前节点复制一份，node始终为实际链表中被删除的那个节点。用复制来的那个节点操作node.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = node; <span class="comment">//复制, 更好理解。其实可以不复制</span></span><br><span class="line">    <span class="comment">//操作实际链表上的那个节点</span></span><br><span class="line">    node.val = current.next.val;</span><br><span class="line">    node.next = current.next.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="8宝石与石头">8.宝石与石头</span></h3><blockquote>
<p> 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：拆成数组，利用includes方法遍历已有宝石，返回true则统计加1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J,S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> splitedJ = J.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> splitedS = S.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    splitedS.forEach(<span class="function"><span class="params">owned</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(splitedJ.includes(owned)) sum++;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//53%</span></span><br><span class="line"><span class="comment">//一定要遍历已有的数组吗?</span></span><br></pre></td></tr></table></figure>

<p>法力浮桥的解法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J,S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> jewelsSet = <span class="keyword">new</span> <span class="built_in">Set</span>(J.split(<span class="string">''</span>));</span><br><span class="line">    <span class="keyword">return</span> S.split(<span class="string">''</span>).reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> prev + jewelsSet.has(cur);</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希集合？</span></span><br></pre></td></tr></table></figure>

<h3><span id="9猜数字">9.猜数字</span></h3><blockquote>
<p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</p>
<p>输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：guess &#x3D; [1,2,3], answer &#x3D; [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：小A 每次都猜对了。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：就是数组的每项对比，统计相等的个数。我用的reduce,实际用filter也是可以的。借助reduce的index参数，用当前遍历值跟answer数组的index值对比，相同则加一。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> game = <span class="function"><span class="keyword">function</span>(<span class="params">guess, answer</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> result = guess.reduce(<span class="function">(<span class="params">acc,cur,index</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cur === answer[index]? ++acc : acc;  <span class="comment">//这里必须++acc, 不能acc++.有点迷惑性</span></span><br><span class="line">   &#125;,<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//优化, 参考Louise用户的解答.</span></span><br><span class="line"><span class="comment">//PS: single liner也太难理解了..</span></span><br><span class="line"><span class="keyword">var</span> game = <span class="function"><span class="keyword">function</span>(<span class="params">guess,answer</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> guess.reduce(<span class="function">(<span class="params">acc,cur,index</span>)=&gt;</span>acc + (cur === answer[index]),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计新思路，利用隐式转换，直接数字和条件进行相加。</span></span><br><span class="line"><span class="comment">//filter方法，参考静呆呆用户的解答。</span></span><br><span class="line"><span class="keyword">var</span> game = <span class="function"><span class="keyword">function</span>(<span class="params">guess, answer</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> guess.filter(<span class="function">(<span class="params">item,index</span>)=&gt;</span>item === answer[index]).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="番外买啤酒">番外：买啤酒</span></h4><blockquote>
<p>10元买啤酒,2元1瓶，4个盖换1瓶，2空瓶换1瓶。总共可以获得多少瓶啤酒？</p>
</blockquote>
<p>15瓶，剩余1空瓶，3盖。跟踪已买、盖数量、空瓶数量、额外数量..没用程序写出来，全程手写跟踪..</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

