<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Future Li">
  <!-- Open Graph Data -->
  <meta property="og:title" content="LeetCode"/>
  <meta property="og:description" content="Hello World!" />
  <meta property="og:site_name" content="CodingLiveLi"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="CodingLiveLi" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>CodingLiveLi</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">LeetCode</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/FutureProgrammerLi" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:617612567@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Future Li</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-10-19</span>
            <span class="time">23:49:11</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/%E7%AE%97%E6%B3%95/">#算法</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <blockquote>
<p>每天一题简单算法题吧，不知能坚持多久。But , small changes count :) </p>
</blockquote>
<h3><span id="1比较含退格的字符串">1.比较含退格的字符串</span></h3><blockquote>
<p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路： 一开始我找井号的索引，然后连续删除这个索引及之前的两个数。发现过不了’ab##’这个测试用例。之后用<strong>栈</strong>，遇到井号就弹出，不是则推到另外的数组里面，返回数组的join(‘’)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findPound</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> strArr = str.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> stack = [];  <span class="comment">//新建一个栈，就不怕pop,push影响原来的字符串数组了。</span></span><br><span class="line">    strArr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        item === <span class="string">'#'</span> ? stack.pop() : stack.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> stack.join(<span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> backspaceCompare = <span class="function"><span class="keyword">function</span> (<span class="params">S,T</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findPound(S) === findPound(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2一维数组的动态和">2.一维数组的动态和</span></h3><blockquote>
<p>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</p>
<p>请返回 nums 的动态和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路: 求和第一反应就想到reduce, 不过里面逻辑应该可以优化.我的做法是根据当前索引,如果索引大于等于0,就将对应索引的值相加,之后索引值减1,直到索引值为0.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runningSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result = nums.reduce(<span class="function">(<span class="params">acc,cur,index,whole</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">let</span> sum = <span class="number">0</span>;  <span class="comment">//结果数组的每一项</span></span><br><span class="line">       <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">           sum = sum + whole[index]; </span><br><span class="line">           index--;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">//如索引index为2,以上逻辑就是nums[2]+nums[1]+nums[0];到index===-1时跳出循环</span></span><br><span class="line">       acc.push(sum);</span><br><span class="line">       <span class="keyword">return</span> acc;</span><br><span class="line">   &#125;,[]);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//40%</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单实现</span></span><br><span class="line"><span class="keyword">var</span> runningSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = nums[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作者：shou-wang-20</span></span><br><span class="line"><span class="comment">//来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">//思路:从数组第二项开始,结果的下一项是前一项和当前项的和.</span></span><br><span class="line"><span class="comment">//95%</span></span><br></pre></td></tr></table></figure>

<h3><span id="3字符串左旋转">3.字符串左旋转</span></h3><blockquote>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路: 围绕字符串的slice,substr, substring方法,结合实现.根据k截取前k位和后面部分,再拼接即可.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="function"><span class="keyword">function</span>(<span class="params">s, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.substr(n,s.length) + s.slice(<span class="number">0</span>,n);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//substr(from,length)</span></span><br><span class="line"><span class="comment">//substring(start,end)</span></span><br><span class="line"><span class="comment">//slice(start,end)</span></span><br><span class="line"><span class="comment">//64%</span></span><br></pre></td></tr></table></figure>

<h3><span id="4好数对的数目">4.好数对的数目</span></h3><blockquote>
<p>给你一个整数数组 nums 。</p>
<p>如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。</p>
<p>返回好数对的数目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,1,1,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路： 两个索引,i和j。i代表当前，j代表i之后的所有。i逐渐右移，变大，j扫描次数（对比次数）逐渐缩小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numIdenticalPairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;= nums.length - <span class="number">2</span>; i++)&#123;  <span class="comment">//注意这里的等号。nums[nums.length-1]是最后一个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt;= nums.length <span class="number">-1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] === nums[j])&#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//60%</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表解法，元素只是作为属性名，结果依赖属性值。</span></span><br><span class="line"><span class="keyword">var</span> numIdenticalPairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, map = &#123;&#125;;</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(map[num])&#123;    <span class="comment">//已经出现过的元素</span></span><br><span class="line">           count += map[num];   <span class="comment">//累计和, 1+2+3+4 ...</span></span><br><span class="line">           map[num]++;          <span class="comment">//出现次数+1(?)</span></span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           map[num] = <span class="number">1</span>;  <span class="comment">//第一次扫描到的元素</span></span><br><span class="line">       &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哈希表统计元素出现次数?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countTimes</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = arr.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(cur <span class="keyword">in</span> acc)&#123;</span><br><span class="line">           acc[cur]++;</span><br><span class="line">       &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">           acc[cur] = <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5拥有最多糖果的孩子">5.拥有最多糖果的孩子</span></h3><blockquote>
<p>给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。</p>
<p>对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：candies &#x3D; [2,3,5,1,3], extraCandies &#x3D; 3</span><br><span class="line">输出：[true,true,true,false,true] </span><br><span class="line">解释：</span><br><span class="line">孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：找出数组的最大值；遍历数组，单项的值加上所有的extracandies大于等于最大值的话，返回true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kidsWithCandies = <span class="function"><span class="keyword">function</span>(<span class="params">candies, extraCandies</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...candies);</span><br><span class="line">    <span class="keyword">let</span> result = candies.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        cur + extraCandies &gt;= max? acc.push(<span class="literal">true</span>) : acc.push(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,[]);</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接map</span></span><br><span class="line"><span class="comment">//return candies.map(item=&gt;item + extraCandies &gt;= max );</span></span><br></pre></td></tr></table></figure>

<h3><span id="6重排数组">6.重排数组</span></h3><blockquote>
<p>给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。</p>
<p>请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,5,1,3,4,7], n &#x3D; 3</span><br><span class="line">输出：[2,3,5,4,1,7] </span><br><span class="line">解释：由于 x1&#x3D;2, x2&#x3D;5, x3&#x3D;1, y1&#x3D;3, y2&#x3D;4, y3&#x3D;7 ，所以答案为 [2,3,5,4,1,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：毫无效率的暴力算法。2n个数要执行n次。新数组, push索引为0 ,n , 1, n+1 ,2,n+2的值..</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shuffle = <span class="function"><span class="keyword">function</span>(<span class="params">nums, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> j = n + i;</span><br><span class="line">        result.push(nums[i],nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//64%</span></span><br></pre></td></tr></table></figure>

<h3><span id="7删除中间节点">7.删除中间节点</span></h3><blockquote>
<p>实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：只能访问被删除的节点。将当前节点复制一份，node始终为实际链表中被删除的那个节点。用复制来的那个节点操作node.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = node; <span class="comment">//复制, 更好理解。其实可以不复制</span></span><br><span class="line">    <span class="comment">//操作实际链表上的那个节点</span></span><br><span class="line">    node.val = current.next.val;</span><br><span class="line">    node.next = current.next.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="8宝石与石头">8.宝石与石头</span></h3><blockquote>
<p> 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：拆成数组，利用includes方法遍历已有宝石，返回true则统计加1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J,S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> splitedJ = J.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> splitedS = S.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    splitedS.forEach(<span class="function"><span class="params">owned</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(splitedJ.includes(owned)) sum++;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//53%</span></span><br><span class="line"><span class="comment">//一定要遍历已有的数组吗?</span></span><br></pre></td></tr></table></figure>

<p>法力浮桥的解法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newJewelsInStones = <span class="function"><span class="keyword">function</span>(<span class="params">J,S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> jewelsSet = <span class="keyword">new</span> <span class="built_in">Set</span>(J.split(<span class="string">''</span>));</span><br><span class="line">    <span class="keyword">return</span> S.split(<span class="string">''</span>).reduce(<span class="function">(<span class="params">prev,cur</span>)=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> prev + jewelsSet.has(cur);</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希集合？</span></span><br></pre></td></tr></table></figure>

<h3><span id="9猜数字">9.猜数字</span></h3><blockquote>
<p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</p>
<p>输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：guess &#x3D; [1,2,3], answer &#x3D; [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：小A 每次都猜对了。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：就是数组的每项对比，统计相等的个数。我用的reduce,实际用filter也是可以的。借助reduce的index参数，用当前遍历值跟answer数组的index值对比，相同则加一。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> game = <span class="function"><span class="keyword">function</span>(<span class="params">guess, answer</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> result = guess.reduce(<span class="function">(<span class="params">acc,cur,index</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cur === answer[index]? ++acc : acc;  <span class="comment">//这里必须++acc, 不能acc++.有点迷惑性</span></span><br><span class="line">   &#125;,<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//优化, 参考Louise用户的解答.</span></span><br><span class="line"><span class="comment">//PS: single liner也太难理解了..</span></span><br><span class="line"><span class="keyword">var</span> game = <span class="function"><span class="keyword">function</span>(<span class="params">guess,answer</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> guess.reduce(<span class="function">(<span class="params">acc,cur,index</span>)=&gt;</span>acc + (cur === answer[index]),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计新思路，利用隐式转换，直接数字和条件进行相加。</span></span><br><span class="line"><span class="comment">//filter方法，参考静呆呆用户的解答。</span></span><br><span class="line"><span class="keyword">var</span> game = <span class="function"><span class="keyword">function</span>(<span class="params">guess, answer</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> guess.filter(<span class="function">(<span class="params">item,index</span>)=&gt;</span>item === answer[index]).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="番外买啤酒">番外：买啤酒</span></h4><blockquote>
<p>10元买啤酒,2元1瓶，4个盖换1瓶，2空瓶换1瓶。总共可以获得多少瓶啤酒？</p>
</blockquote>
<p>15瓶，剩余1空瓶，3盖。跟踪已买、盖数量、空瓶数量、额外数量..没用程序写出来，全程手写跟踪..</p>
<h3><span id="10拿硬币">10.拿硬币</span></h3><blockquote>
<p>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p>
<p>示例 1：</p>
<p>输入：[4,2,1]</p>
<p>输出：4</p>
<p>解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</p>
</blockquote>
<p>思路： 降级版买啤酒。遍历数组，能除以2的就直接除以2，不能的除以二后取整。主要用Math.ceil和reduce。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCount = <span class="function"><span class="keyword">function</span>(<span class="params">coins</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = coins.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> acc += <span class="built_in">Math</span>.ceil(cur/<span class="number">2</span>);      </span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是整数的直接向上取整。是整数的 cur/2 === Math.ceil(cur/2), 就不用额外判断了。</span></span><br><span class="line"><span class="comment">//为了容易看就不直接return coins.reduce了。</span></span><br></pre></td></tr></table></figure>

<h3><span id="11整数的各位积和之差">11.整数的各位积和之差</span></h3><blockquote>
<p> 给你一个整数 <code>n</code>，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</p>
<p>示例 1：</p>
<p>输入：n = 234<br>输出：15<br>解释：<br>各位数之积 = 2 * 3 * 4 = 24<br>各位数之和 = 2 + 3 + 4 = 9<br>结果 = 24 - 9 = 15</p>
</blockquote>
<p>思路： 暴力解法，先将数字转成字符串（用于分离），再将字符串转成数字（用于计算），然后数组求积，求和，返回结果差。（过于暴力，毫无想法）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subtractProductAndSum = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> splitedNumber = n.toString().split(<span class="string">''</span>).map(<span class="function"><span class="params">i</span>=&gt;</span><span class="built_in">parseInt</span>(i));</span><br><span class="line">    <span class="keyword">let</span> pro = splitedNumber.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        acc *= cur;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> sub = splitedNumber.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        acc += cur;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> pro - sub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有意思的解法:利用eval，参考MuddledKami的写法:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> subtractProductAndSum = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = n.toString().split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">eval</span>(arr.join(<span class="string">'*'</span>));</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">eval</span>(arr.join(<span class="string">'+'</span>));</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="12括号的最大嵌套深度">12.括号的最大嵌套深度</span></h3><blockquote>
<p>描述一大堆，就是求最深的括号是多少层</p>
<p>例如：””、”()()”、”()(()())” 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 “)(“ 、”(()” 都不是 有效括号字符串 。</p>
<p>给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;(1+(2*3)+((8)&#x2F;4))+1&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：数字 8 在嵌套的 3 层括号中。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路： 利用栈，遇到左括号，入栈，修改一次最大深度；遇到右括号，出栈，深度不变。<strong>利用好栈的最大长度</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> maxDep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === <span class="string">'('</span>)&#123;</span><br><span class="line">            stack.push(s[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i] === <span class="string">')'</span>)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        maxDep = <span class="built_in">Math</span>.max(maxDep,stack.length);   <span class="comment">//关键点</span></span><br><span class="line">        <span class="comment">//一个左括号都没有就取maxDep,遇到一个就取stack.length</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> maxDep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stack.length有增有减，增的峰值就是最大深度。</span></span><br></pre></td></tr></table></figure>

<h3><span id="13按既定顺序创建目标函数">13.按既定顺序创建目标函数</span></h3><blockquote>
<p>给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：</p>
<p>目标数组 target 最初为空。<br>按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。<br>重复上一步，直到在 nums 和 index 中都没有要读取的元素。<br>请你返回目标数组。</p>
<p>题目保证数字插入位置总是存在。</p>
<p>输入：nums = [0,1,2,3,4], index = [0,1,2,2,1]<br>输出：[0,4,1,3,2]<br>解释：<br>nums       index     target<br>0            0        [0]<br>1            1        [0,1]<br>2            2        [0,1,2]<br>3            2        [0,1,3,2]<br>4            1        [0,4,1,3,2]</p>
</blockquote>
<p>思路： 概括题目就是，新创建数组，在index[i]的索引下插入nums[i]这个值.利用splice就行。一开始我还判断该索引下是否有值，没值的时候才赋值,担心只用splice会覆盖..结果..多虑了</p>
<p>一个重要的先要条件是, nums.length === index.length;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createTargetArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> target = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> realIndex = index[i];</span><br><span class="line">        <span class="keyword">let</span> realNum = nums[i];</span><br><span class="line">        <span class="comment">//if(target[realIndex] === 0 || target[realIndex])&#123;  //这里的if/else是多余的</span></span><br><span class="line">            target.splice(realIndex,<span class="number">0</span>,realNum);</span><br><span class="line">        <span class="comment">//&#125;else&#123;</span></span><br><span class="line">        <span class="comment">//    target[realIndex] = realNum;</span></span><br><span class="line">        <span class="comment">//&#125;;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="14解压缩编码列表">14.解压缩编码列表</span></h3><blockquote>
<p>给你一个以行程长度编码压缩的整数列表 nums 。</p>
<p>考虑每对相邻的两个元素 [freq, val] = [nums[2<em>i], nums[2</em>i+1]] （其中 i &gt;= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>
<p>请你返回解压后的列表。</p>
<p>输入：nums = [1,2,3,4]<br>输出：[2,4,4,4]<br>解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。<br>第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。<br>最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。</p>
</blockquote>
<p>题目理解：将数组拆成若干元组，键为值出现在新数组中的次数，值就是新数组的值。</p>
<p>思路：双循环，一个控制元组分割，一个控制新数组值的push.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decompressRLElist = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;nums.length; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j&lt;nums[i]; j++)&#123;</span><br><span class="line">            result.push(nums[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有意思（花里胡哨）的解法: 解构，fill</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decompressRLElist = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;nums.length; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        res.push(...Array(nums[i].fill(nums[i+<span class="number">1</span>])));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//个人认为不好理解..没双循环直观</span></span><br></pre></td></tr></table></figure>

<h3><span id="15所有奇数长度子数组的和">15.所有奇数长度子数组的和</span></h3><blockquote>
<p>给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。</p>
<p>子数组 定义为原数组中的一个连续子序列。</p>
<p>请你返回 arr 中 所有奇数长度子数组的和 。</p>
<p>输入：arr = [1,4,2,5,3]<br>输出：58<br>解释：所有奇数长度子数组和它们的和为：<br>[1] = 1<br>[4] = 4<br>[2] = 2<br>[5] = 5<br>[3] = 3<br>[1,4,2] = 7<br>[4,2,5] = 11<br>[2,5,3] = 10<br>[1,4,2,5,3] = 15<br>我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</p>
</blockquote>
<p>题目： 很好理解，取出奇数项的子数组，将所有的子数组求和。</p>
<p>思路：第一反应是slice和reduce,但自己没想到如何控制好外层的循环，一个循环控制步长，一个控制子数组的长度。最后参考了喜个阳阳的写法。主要是外层的两个循环问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOddLengthSubarrays = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= arr.length; i+=<span class="number">2</span>)&#123;   <span class="comment">//控制步长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span> ; j + i &lt;= arr.length; j++)&#123;   <span class="comment">//控制求和，遍历子数组</span></span><br><span class="line">            sum += arr.slice(j,i).reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>acc+cur,<span class="number">0</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//个人认为是没想到 j+i &lt;= arr.length这个条件</span></span><br></pre></td></tr></table></figure>

<h3><span id="16独一无二的出现次数">16.独一无二的出现次数</span></h3><blockquote>
<p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,1,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路： 我利用了两次reduce,一次统计每个元素出现的次数，一次统计出现的次数是否唯一。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">acc,cur</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(acc[cur])&#123;</span><br><span class="line">        acc[cur]++;  <span class="comment">//已出现一次，能走到这的起码在数组中出现了两次</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        acc[cur] = <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> uniqueOccurrences = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> hashOne = arr.reduce(reducer,&#123;&#125;);  <span class="comment">//统计每个元素出现的次数,属性为项，值为次数</span></span><br><span class="line">  <span class="keyword">let</span> times = <span class="built_in">Object</span>.values(hashOne);    <span class="comment">//单独将次数取出来</span></span><br><span class="line">  <span class="keyword">let</span> hashTwo = times.reduce(reducer,&#123;&#125;);  </span><br><span class="line">  <span class="keyword">let</span> result = <span class="built_in">Object</span>.values(hashTwo).every(<span class="function"><span class="params">i</span>=&gt;</span> i === <span class="number">1</span>); <span class="comment">//判断出现的次数都只为1次</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//60%</span></span><br></pre></td></tr></table></figure>

<p>收获： </p>
<ol>
<li><p>哈希表统计元素出现的次数</p>
</li>
<li><p>判断元素在数组中是否唯一(Object.values(hashMap).every(i=&gt;i ===1);)</p>
</li>
<li><p>用Set去重后，判断和原来的出现次数的数组的长度是否相同。相同则独一无二。</p>
<p>比如出现的次数为[1,2,2,3]. new Set(…arr) =&gt; [1,2,3], arr.length !== set.size,长度不等,即出现次数不是唯一。</p>
</li>
</ol>
<h3><span id="17-统计位数为偶数的数字">17 统计位数为偶数的数字</span></h3><blockquote>
<p>给你一个整数数组 <code>nums</code>，请你返回其中位数为 <strong>偶数</strong> 的数字的个数。</p>
<p>输入：nums = [12,345,2,6,7896]<br>输出：2<br>解释：<br>12 是 2 位数字（位数为偶数）<br>345 是 3 位数字（位数为奇数）<br>2 是 1 位数字（位数为奇数）<br>6 是 1 位数字 位数为奇数）<br>7896 是 4 位数字（位数为偶数）<br>因此只有 12 和 7896 是位数为偶数的数字</p>
</blockquote>
<p>思路： 转成字符串，统计字符串的长度，能整除2则统计+1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = nums.reduce(<span class="function">(<span class="params">acc,cur</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> strNum = cur.toString().split(<span class="string">''</span>);</span><br><span class="line">        strNum.length % <span class="number">2</span> === <span class="number">0</span>? acc++ : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="18-求矩阵对角线的和">18 求矩阵对角线的和</span></h3><blockquote>
<p>示例 [[1,2,3],[4,5,6],[7,8,9]]。n*n矩阵，对角线的和则为1+5+9 +3+7 = 25.中心元素只加一次。</p>
</blockquote>
<p>思路：双指针，以矩阵的单行为单位，判断是否为中心元素，是的话只加一次，否则正方形，四个四个地加。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> diagonalSum = <span class="function"><span class="keyword">function</span> (<span class="params">mat</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>, b = mat.length - <span class="number">1</span>;    <span class="comment">//矩阵长度等价于每个数组的长度</span></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a&lt;=b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a === b)&#123;</span><br><span class="line">            sum += mat[a][a];   <span class="comment">//中心元素，下标无所谓</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum += mat[a][a]+mat[a][b]+mat[b][a]+mat[b][b];</span><br><span class="line">        &#125;;</span><br><span class="line">        a++;</span><br><span class="line">        b--;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="19-二进制链表转整数">19 二进制链表转整数</span></h3><blockquote>
<p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p>
<p>请你返回该链表所表示数字的 十进制值 。</p>
<p>链表Node是对象，Node{this.val = val; this.next = null;}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,0,1]</span><br><span class="line">输出：5</span><br><span class="line">解释：二进制数 (101) 转化为十进制数 (5)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路:遍历链表，将每个节点的值通过字符串连接起来，之后利用parseInt的两个参数将字符串转化为10进制数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDecimalValue = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur !== <span class="literal">null</span>)&#123;</span><br><span class="line">        result += cur.val;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(result,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="20重新排列字符串">20.重新排列字符串</span></h3><blockquote>
<p>给你一个字符串 s 和一个 长度相同 的整数数组 indices 。</p>
<p>请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置。</p>
<p>返回重新排列后的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aiohn&quot;, indices &#x3D; [3,1,4,2,0]</span><br><span class="line">输出：&quot;nihao&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>思路：关键点是 indices[i]为结果字符串s[i]所在的位置。可以用hashMap，也可以直接用数组。我认为map好理解，数组更加直观。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> restoreString = <span class="function"><span class="keyword">function</span>(<span class="params">s,indices</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;  <span class="comment">//s.length === indices.length , 所以用哪个无所谓</span></span><br><span class="line">        map[indices[i]] = s[i];    <span class="comment">//属性为结果字符串的位置，值为对应字符</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.values(map).join(<span class="string">''</span>);  <span class="comment">//较数组比较麻烦了的一步</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对象自动排序了属性名</span></span><br><span class="line"><span class="keyword">var</span> restoreString = <span class="function"><span class="keyword">function</span>(<span class="params">s,indices</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;s.length; i++)&#123;</span><br><span class="line">        arr[indices[i]] = s[i];       <span class="comment">//意思是一样的</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="21分割平衡字符串">21.分割平衡字符串</span></h3><blockquote>
<p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给出一个平衡字符串 <code>s</code>，请你将它分割成尽可能多的平衡字符串。</p>
<p>返回可以通过分割得到的平衡字符串的最大数量<strong>。</strong></p>
<p>示例 1：</p>
<p>输入：s = “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”, “RRLL”, “RL”, “RL”, 每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’。</p>
</blockquote>
<p>思路： 原本以为用栈解决，细想发现并不需要，不过思想是类似的。一个哨兵，指示当前是R还是L，R则+1，</p>
<p>L则-1，哨兵等于零，则代表遇到一个平衡字符串，统计数+1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balancedStringSplit = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> char <span class="keyword">of</span> s)&#123;</span><br><span class="line">        char === <span class="string">'R'</span> &amp;&amp; index++;</span><br><span class="line">        char === <span class="string">'L'</span> &amp;&amp; index--;</span><br><span class="line">        index === <span class="number">0</span> &amp;&amp; count++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//问题: RRL这个用例应该返回1还是0？</span></span><br></pre></td></tr></table></figure>

<h3><span id="22二叉树的深度">22.二叉树的深度</span></h3><blockquote>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]，</p>
<p>​    3</p>
<p>   / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p>
</blockquote>
<p>思路: 左右子树最大深度加上根节点的1.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">let</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left,right) + <span class="number">1</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果只给了树节点个数(一般不可能,而是给根节点让你遍历下去)</span></span><br><span class="line"><span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.log(tree.length) / <span class="built_in">Math</span>.log(<span class="number">2</span>)) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//原理: 深度为k的树总节点数最多为(2^k)-1</span></span><br><span class="line"><span class="comment">//另外常识: 二叉树第i层节点数最多为2^(i-1)个</span></span><br></pre></td></tr></table></figure>

<h3><span id="23二叉树的镜像">23.二叉树的镜像</span></h3><blockquote>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
<pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>镜像输出：</p>
<pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1</p>
<p>示例 1：</p>
<p>输入：root = [4,2,7,1,3,6,9]<br>输出：[4,7,2,9,6,3,1]</p>
</blockquote>
<p>思路：递归.借助临时变量交换左右节点，然后递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> tmp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    </span><br><span class="line">    mirrorTree(root.left);</span><br><span class="line">    mirrorTree(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    [root.left, root.right] = [mirrorTree(root.right),mirrorTree(root.left)];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//神奇解法</span></span><br></pre></td></tr></table></figure>


        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

