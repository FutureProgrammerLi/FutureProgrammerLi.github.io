<!DOCTYPE html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="composition-api-rfc"><meta name="author" content="Future Li"><meta name="keywords" content="vue"><meta name="copyright" content="copyright.liscense_type"><title>Composition-Api-Rfc</title><!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]><script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script><script src="https://cdn.bootcss.com/respond/1.4.2/respond.min.js"></script><![endif]--><link rel="icon" href="/compass/imgs/favicon.ico"><link rel="stylesheet" href="/compass/stylesheets/font-awesome.min.css"><script>var algoliaConfig = {"on":false}</script><link rel="stylesheet" href="/compass/stylesheets/screen.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div id="body-inner-wrapper"><header id="page-header"><nav id="nav"><div id="site-name">CodingLiveLi</div><i class="fa fa-bars fa-2x" id="nav-icon" aria-hidden="true"></i><div id="nav-expanded"><a class="nav-word-item" href="/">Home</a><a class="nav-word-item" href="/archives">Archives</a></div><div id="nav-list"><ul><li><a class="nav-list-item" href="/">Home</a></li><li><a class="nav-list-item" href="/archives">Archives</a></li></ul></div></nav><div id="banner-wrapper"><div id="banner-pagetype-dependent-info"><h1 id="post-title">Composition-Api-Rfc</h1><span id="post-description"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-21</span><span id="word-count">The total word count - 1893</span><span id="time-count">Estimated time of reading - 7 mins</span></div></div><a title="Back to Top"><i class="fa fa-arrow-up" id="to-Top" aria-hidden="true"></i></a><a title="Click to Toggle off"><i class="fa fa-toggle-on" id="toggle-on-Toc" aria-hidden="true"></i></a><a title="Click to Toggle on"><i class="fa fa-toggle-off" id="toggle-off-Toc" aria-hidden="true"></i></a></header><aside id="toc-column"><div id="toc-column-inner-wrapper"><div id="post-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#null"><span class="toc-text">Setup(props,context)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">props</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">context</span></a></li></ol></li></ol></div></div></aside><main id="main-content-column"><div id="main-content-wrapper"><div id="post-full-content"><blockquote>
<p>之前好像有看过，也做了笔记。对比一下发布前和发布后官网教程的区别咯。 发现是第三次阅读了.. <a href="https://codingliveli.netlify.app/2020/06/29/%E9%87%8D%E8%AF%BBvue3-rfc/" target="_blank" rel="noopener">传送门</a></p>
<p>用例并不一样。传送门里的内容更有深度。</p>
</blockquote>
<h1><span id="introduction">Introduction</span></h1><p>主线： 一个根据ID获得的仓库列表展示，可以过滤和搜索。</p>
<p>“When working on a large component, we have to constantly ‘jump’ around option blocks to for the relevant feature.”  –Why we need composition API.</p>
<p>No data ,methods or anything of the instance is available except <code>props</code>.</p>
<p>Anything returned by the <code>setup()</code> function is available for the options and the template.</p>
<p>(还想另起文章写如何尤大和掘金文章，react hooks异步请求数据的区别..官网教程就有了..也当作对比吧)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; fetchUserRepositories &#125; from &#39;@&#x2F;api&#x2F;repositories&#39;;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">setup (props) &#123; </span><br><span class="line">    &#x2F;&#x2F;inside our component</span><br><span class="line">  let repositories &#x3D; [];  </span><br><span class="line">    &#x2F;&#x2F;problem: not reactive, no re-render</span><br><span class="line">  const getUserRepositories &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    repositories &#x3D; await fetchUserRepositories(props.user)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories </span><br><span class="line">      &#x2F;&#x2F; functions returned behave the same as methods</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Use <code>ref()</code> to wrap up a primitive value because primitive values are passed by value but not reference.We have to keep track of the same value(?)</strong></p>
<p>If ref() recieves a reference type of value , it’s ok and become reactive.(Don’t worry about using ref for Objects!)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; reactive &#125; from &#39;vue&#39;;</span><br><span class="line">let repositories &#x3D; ref([]);</span><br><span class="line">&#x2F;&#x2F;The rest stay the same</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>Lifecycle hooks in setup() function have the same name as for Options API but are with the prefixed <code>on</code></p>
<p><code>onMounted</code>,<code>onBeforeMount</code>,<code>onBeforeUnmounted</code>,<code>onUnmounted</code> …TEN lifecycle hooks in total: 8 for normal usage and 2 for debugging purpose.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;Call the async func once the instance is mounted.</span><br><span class="line">import &#123; onMounted &#125; from &#39;vue&#39;;</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">onMounted(getUserRepositories);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>直接将函数定义传进去，<u>别将函数返回值传了进去</u></strong></p>
<p>Now, we need to trigger the function once the prop <code>userId</code> is changed.</p>
<p>Therefore , a <code>watch()</code> API is needed.It receives three params:</p>
<ol>
<li>A reactive reference or a getter function(hint for computed property?)</li>
<li>A callback once the watched proptery is changed.</li>
<li>Optional configuration options.</li>
</ol>
<p>To stop the watch , you can use the value returned by the watch function.</p>
<p>The <code>watch()</code> return a function which can stop the watcher.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stop = watch(counter,()=&gt;<span class="built_in">console</span>.log(counter));</span><br><span class="line">stop(); <span class="comment">//manually stop the watcher.</span></span><br></pre></td></tr></table></figure>



<p>So the whole feature code may look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; fetchUserRepositories &#125; from &#39;@&#x2F;api&#x2F;repositories&#39;</span><br><span class="line">import &#123; ref, onMounted, watch, toRefs &#125; from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line">setup(props)&#123;</span><br><span class="line">    const &#123; user &#125; &#x3D; toRefs(props);</span><br><span class="line">    &#x2F;&#x2F;Make the props reactive so the component can react to its change.</span><br><span class="line">    const repositories &#x3D; ref([]);</span><br><span class="line">    const getUserRepositories &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">        repositories.value &#x3D; await fetchUserRepositories(user.id);</span><br><span class="line">    &#125;</span><br><span class="line">    onMounted(getUserRepositories);</span><br><span class="line">    watch(user,getUserRepositories);</span><br><span class="line">    return &#123;</span><br><span class="line">        repositories,</span><br><span class="line">        getUserRepositories</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>Now, the feature of getting the data is done. Let’s move on to the <code>searchQuery</code> utility.</p>
<p><code>computed()</code> can receive a getter function which returns a read-only reactive reference.It works similarly like ref, but it’s read-only.(You can pass in an object, setting the getter function and the setter function.)</p>
<p>The function passed into computed is regarded as the getter function by default.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;same in the setup function.</span><br><span class="line">import &#123; computed &#125; from &#39;vue&#39;;</span><br><span class="line">setup(props)&#123;</span><br><span class="line">    &#x2F;&#x2F;...get repositories feature</span><br><span class="line">    const searchQuery &#x3D; ref(&#39;&#39;);</span><br><span class="line">    const repositoriesMatchingSearchQuery &#x3D; computed(()&#x3D;&gt;&#123;  &#x2F;&#x2F;what a name..</span><br><span class="line">        return repositories.value.filter(repo&#x3D;&gt;repo.name.includes(searchQuery.value));</span><br><span class="line">    &#125;); </span><br><span class="line">    return &#123;</span><br><span class="line">        repositories,   </span><br><span class="line">        getUserRepositories, &#x2F;&#x2F;show up here for further discussion</span><br><span class="line">        searchQuery,  &#x2F;&#x2F;for model binding use.</span><br><span class="line">        repositoriesMatchingSearchQuery</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>Will the object returned by setup() be extremely big overtime？</p>
<p>Yes.But you can extract to standalone functions:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; fetchUserRepositories &#125; from &#39;@&#x2F;api&#x2F;repositories&#39;</span><br><span class="line">import &#123; ref, onMounted, watch &#125; from &#39;vue&#39;</span><br><span class="line">&#x2F;&#x2F;Remember to keep track of the params user.</span><br><span class="line">export default function useUserRepositories(user) &#123;</span><br><span class="line">  const repositories &#x3D; ref([])</span><br><span class="line">  const getUserRepositories &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">    repositories.value &#x3D; await fetchUserRepositories(user.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(getUserRepositories)</span><br><span class="line">  watch(user, getUserRepositories)</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    repositories,</span><br><span class="line">    getUserRepositories</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; computed &#125; from &#39;vue&#39;;</span><br><span class="line">&#x2F;&#x2F;Here for repositories</span><br><span class="line">export default function useRepositoryNameSearch(repositories)&#123; </span><br><span class="line">    &#x2F;&#x2F;...get repositories feature</span><br><span class="line">    const searchQuery &#x3D; ref(&#39;&#39;);</span><br><span class="line">    const repositoriesMatchingSearchQuery &#x3D; computed(()&#x3D;&gt;&#123;  &#x2F;&#x2F;what a name..</span><br><span class="line">        return repositories.value.filter(repo&#x3D;&gt;repo.name.includes(searchQuery.value));</span><br><span class="line">    &#125;); </span><br><span class="line">    return &#123;</span><br><span class="line">        searchQuery,  &#x2F;&#x2F;for model binding use.</span><br><span class="line">        repositoriesMatchingSearchQuery</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;in the component</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    user: &#123; type: String &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  setup (props) &#123;</span><br><span class="line">    const &#123; user &#125; &#x3D; toRefs(props)</span><br><span class="line"></span><br><span class="line">    const &#123; repositories, getUserRepositories &#125; &#x3D; useUserRepositories(user)</span><br><span class="line"></span><br><span class="line">    const &#123;</span><br><span class="line">      searchQuery,</span><br><span class="line">      repositoriesMatchingSearchQuery</span><br><span class="line">    &#125; &#x3D; useRepositoryNameSearch(repositories)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      &#x2F;&#x2F; Since we don’t really care about the unfiltered repositories</span><br><span class="line">      &#x2F;&#x2F; we can expose the filtered results under the &#96;repositories&#96; name</span><br><span class="line">      repositories: repositoriesMatchingSearchQuery,</span><br><span class="line">      getUserRepositories,</span><br><span class="line">      searchQuery,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Did we actually reduce the size of the object returned?</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>Filter feature can be fulfilled by the same APIs. So, just skip the part.</p>
<hr>
<h1><span id="setuppropscontext">Setup(props,context)</span></h1><p>This entry function receives two params: props and context.</p>
<p><strong>What is reactive cannot be detructured or you need to wrap it up with toRefs().</strong></p>
<p>props is reactive but context is not. setup(props,{ attrs, slot, emit }) is correct.</p>
<p>props do nothing with the setup if you’re not using props in the setup function.</p>
<p>(Don’t return any props in the setup function.Props are automatically accessible to the template)</p>
<h2><span id="props">props</span></h2><p>props needs to be declared out of setup but inside the instance.</p>
<p>Any props used in the setup function must be declared by props option.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">    props:&#123;user:String&#125;,</span><br><span class="line">    setup(props)&#123;</span><br><span class="line">        const &#123; user &#125; &#x3D; toRefs(props); &#x2F;&#x2F;Using destructure safely to keep reactivity</span><br><span class="line">                             &#x2F;&#x2F;Directly destructure will lead to the loss of reactivity</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>To know what a props can be , check out this <a href="https://codingliveli.netlify.app/2020/10/11/vue%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">article</a></p>
<h2><span id="context">context</span></h2><p>A normal JS object containing three keys: attrs, slots, emit.</p>
<p><strong>Since attrs and slots are not reactive , do side effects inside the <code>onUpdated</code> lifecycle hook if one of them is changed</strong></p>
<p>Data , methods, computed options in the component is not accessible in setup().</p>
<p><code>this</code> keyword in setup does not act the same as that of other options.Be careful of using it.</p>
<p><strong>setup can return a render function , with the same usage of any other composition API</strong></p>
<hr>
<p>Only add ways to invoke lifecycle hooks inside setup().</p>
<p><strong><code>beforeDestroy</code> and <code>destroyed</code> are changed into <code>beforeUnmount</code> and <code>unmounted</code></strong></p>
<p>Options ways of invoking lifecycle is still accessible.(Lifecycle hooks like beforeCreate and created stay the same outside of the setup function.)</p>
<p><strong>Inside setup()</strong>, no need for <code>beforeCreate</code> and <code>created</code>, the setup function is invoked at this timing.</p>
<p>Similar to react, only mount, update, and unmount hooks are remained.</p>
<p><strong>List of lifecycle hooks inside setup():</strong></p>
<ol>
<li>onBeforeMount</li>
<li>onMounted</li>
<li>onBeforeUpdate</li>
<li>onUpdated</li>
<li>onBeforeUnmount</li>
<li>onUnmounted</li>
<li>(2 hooks for debugging) onRenderChecked</li>
<li>onRenderTriggered</li>
<li>onErrorCaptured</li>
</ol>
<p><strong>You can invoke the same function outside setup, by removing the prefix <code>on</code>.</strong></p>
<hr>
<p><strong>Provide and inject inside setup()</strong>, ways to sharing states through the components tree from top to bottom.</p>
<p>grammar: <code>provide(&#39;propertyName&#39;,&#39;value&#39;);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; provide &#125; from &#39;vue&#39;;</span><br><span class="line">  export default&#123;</span><br><span class="line">      setup()&#123;</span><br><span class="line">          provide(&#39;location&#39;,&#39;North Pole&#39;);</span><br><span class="line">          provide(&#39;randomObj&#39;,&#123;</span><br><span class="line">              a:&#39;provide&#39;,</span><br><span class="line">              b:&#39;object&#39;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;Only provide one state down to the tree for each provide function invocation.</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>As for inject, same need to explicitly import from vue , and , one invocation, one property.</p>
<p>grammar:<code>inject(&#39;propertyName&#39;,&#39;defaultValue&#39;);</code></p>
<p>The second param is optional, indicating the defalut value once it is not passed down.</p>
<p><strong>To make the provided reactive, you need to wrap it up with ref() or reactive() before you provide it down;Otherwise, it is not reactive.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; provide , ref, reactive &#125; from &#39;vue&#39;;</span><br><span class="line">    export default&#123;</span><br><span class="line">        setup()&#123;</span><br><span class="line">            const val1 &#x3D; ref(0);</span><br><span class="line">            const val2 &#x3D; reactive(&#123;a:1,b:2&#125;);</span><br><span class="line">            provide(&#39;val1&#39;,val1);</span><br><span class="line">            provide(&#39;val2&#39;,val2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>The params in provide() can’t be shortened or ignored.You can renaming the value instead of ignoring it.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">provide(val1);  <span class="comment">//wrong</span></span><br><span class="line">provide(<span class="string">'renameVal1'</span>, val1); <span class="comment">//right</span></span><br></pre></td></tr></table></figure>

<p>It’s recommended to also <strong>inject a mutating way</strong> for some injection property because of its reactivity.Or, inject a <code>readonly()</code> property for child components.</p>
<p><strong>Once a value is passed through <code>provide()</code>, wrap it in readonly(), or pass along with a way of mutating it.</strong></p>
<hr>
<p>Using template refs in composition API.</p>
<p>Declare a ref with the same name of template ref, and it will be bound to the element.</p>
<p>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref&#x3D;&quot;root&quot;&gt;</span><br><span class="line">      Whatever</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref &#125; from &#39;vue&#39;;</span><br><span class="line">  export default &#123;</span><br><span class="line">      setup()&#123;</span><br><span class="line">          const root &#x3D; ref(null);</span><br><span class="line">          return &#123;</span><br><span class="line">              root</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>Self convention: A ref with default value of null indicates that a same ref name exists in the template ref.</p>
<p>(Won’t this make any contradictions?)</p>
</div><div id="post-tags-container"><i class="fa fa-tags"></i> <a class="post-tag" href="/tags/vue/">#vue</a></div><div id="post-categories-container"><i class="fa fa-folder-open"></i>
 <a href="/categories/vue/">vue</a></div></div></main><div id="pagination-wrapper"><a id="page-prev" href="/2020/10/23/hooks%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/"><i class="fa fa-chevron-left"></i> hooks请求数据</a><a id="page-next" href="/2020/10/19/LeetCode/">LeetCode <i class="fa fa-chevron-right"></i></a></div><footer id="page-footer"><div id="footer-wrapper"><div id="blog-meta">&copy;2017-2021 By Future Li | Theme - <a id='theme-name' href="https://github.com/huan555/lemon-lime" target="_blank" rel="noopener"> Lemon-Lime</a> | Power By <a id='theme-powered-by' href=http://hexo.io> Hexo</a></div><div id="viewed-record"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span></span></div><div id="copyright-wrapper"><i class="fa fa-cc" aria-hidden="true"></i><div id="copyright">Except where otherwise noted, content on this blog is licensed under <a rel="license" href=http://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a>.</div></div><div id="contact-me"><div id="rss"><a href="/atom.xml" type="application/atom+xml" rel="alternate" target="_blank"><i class="fa fa-rss" aria-hidden="true"></i></a></div><span id="github"><a href="https://github.com/FutureProgrammerLi" target="_blank" rel="noopener"><i class="fa fa-github" aria-hidden="true"></i></a></span><span id="weibo"><a href="https://weibo.com/1903816767/profile?rightmod=1&amp;wvr=6&amp;mod=personnumber" target="_blank" rel="noopener"><i class="fa fa-weibo" aria-hidden="true"></i></a></span></div></div></footer><script src="/compass/js/blog.js"></script></div></body>