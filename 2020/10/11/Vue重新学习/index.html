<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Future Li">
  <!-- Open Graph Data -->
  <meta property="og:title" content="Vue重新学习"/>
  <meta property="og:description" content="Hello World!" />
  <meta property="og:site_name" content="CodingLiveLi"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="CodingLiveLi" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>CodingLiveLi</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">Vue重新学习</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/FutureProgrammerLi" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:617612567@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Future Li</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-10-11</span>
            <span class="time">22:05:52</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Vue/">Vue</a> / <a href="/categories/Vue/React/">React</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Vue/">#Vue</a> <a class="tag" href="/tags/React/">#React</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1><span id="前言">前言</span></h1><p>用了几个月React。因为我工作前都是用Vue的，刚开始的时候总是想着，这个在Vue里能够轻松实现的功能，比如v-model, v-for,v-if，computed等等，在React中到底要怎么实现呢？React里的展示怎么东一块西一块的，还要在某个总的类里面合并这些东西，也太难看懂了吧？类组件怎么这么难提取，这么难重用？……几个月过去了，嗯！React真香！这一块要做什么，那一块要做什么，一看就懂了，原子看懂了分子就差拼凑了。再看回Vue,对比着Vue2,Vue3,Class Components, Function Components看，Vue2和Class很像, Vue3的Composition API和Hooks很像。不过有一想法还是很强烈的：用了一回React再看Vue，什么，这能简化？什么？这有指令？什么？这都要用API封装？直接点用原生JS，少点花里胡哨不好吗？</p>
<p>​    其实也不难理解，Vue的一大特点就是上手容易，熟悉了这个框架了，要自己写UI库或者扩充它的功能了，你还也可以自己写render functions，甚者自己用它的响应式系统弄些有趣的东西出来。</p>
<p>   现在Vue3正式版也出来了，Official Guide也出来了，我却对Vue更陌生了。秉承对尤大大的崇拜，我就想重新学习一下Vue。感觉也会像当初学React一样，不过可能更多的是思考两种框架实现的差异以及它们为什么要这样做吧。这篇内容来源主要是Cheet Sheet和官网。</p>
<h1><span id="为什么要引入composition-api">为什么要引入Composition API</span></h1><p>Vue3的composition API更像是扩充，因为新的项目里对Options API也是兼容的。在Cheet Sheet里也建议了，在以下这些情况中可以使用Compostion API：</p>
<ul>
<li>当组件的规模过于庞大，而且你想将代码按照功能的实现将代码分段；</li>
<li>代码可以被提取出来，在其他的代码中可以重用，以此来代替过去的Mixins/Slot scopes;</li>
<li>用的TypeSript编写Vue，而且类型的安全性需要得到保证。</li>
</ul>
<p>对比React为什么要推荐使用函数组件代替类组件：</p>
<ul>
<li>逻辑难以重用</li>
<li>组件过于庞大，可能会滥用HOC，引起Wrapper Hell</li>
<li>类组件的this很容易让人混淆（Vue也有这个问题）</li>
<li>类组件不仅人难理解，机器也很难理解。Babel更愿意看到function而不是class。</li>
</ul>
<p>Options API规定你必须把数据放在data，方法放在methods，它并不关心这些数据、这些方法具体是要实现什么功能的。</p>
<p>而Conposition API更关注你要实现什么功能，把相关的数据、方法都放在一起。你需要的话就把它抽出来用。</p>
<p><strong>潜在问题</strong>：Composition API可能会在不经意间丢掉数据的响应性。</p>
<h1><span id="开始使用">开始使用</span></h1><p>重新学习，也想尝尝新，就用尤大开发的Vite来弄个项目出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm init vite-app &lt;project-name&gt;</span><br><span class="line">$ cd &lt;project-name&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev  &#x2F;&#x2F;&quot;scripts&quot;:&#123;&quot;dev&quot;:&quot;vite&quot; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>并不是所有组件都要用Composition API的。主要看使用场合，觉得合适才用。</strong></p>
<ul>
<li>setup()是新增的API，它和之前的data,methods,computed等同级.</li>
<li>onBeforeMounted（setup里面）和beforeMounted(Options API)执行时机是一致的。之前还在迷惑setup执行时机和setup里面执行生命周期的顺序？</li>
</ul>
<ul>
<li><p>components需要注册，不仅要import，还要在父组件里显式声明(components:{}),提供了重命名的功能，但有必要吗？</p>
</li>
<li><p>props需要规范，可以单一声明对应类型，也可以是一个对象，设置默认值，什么时候监听等等。</p>
</li>
<li><p>实际传入的props跟子组件里声明的props类型不一致，不会报错但会警告。渲染出来的还是实际传进来的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default&#123;</span><br><span class="line">props: &#123;  </span><br><span class="line">  &#x2F;&#x2F;type String, Array, Object (Function, validator)</span><br><span class="line">  &#x2F;&#x2F;(the last two choices can be of great usage)</span><br><span class="line">    p1: String,</span><br><span class="line">    p2: [String,Number],</span><br><span class="line">    p3: &#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        required:true</span><br><span class="line">    &#125;,</span><br><span class="line">    p4:&#123;</span><br><span class="line">        type:Object,</span><br><span class="line">        default:() &#x3D;&gt; (&#123;a:&#39;A default prop&#39;&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    p5:&#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        validator: val &#x3D;&gt; val &gt; 5 &#x2F;&#x2F;the pass-in prop number must be greater than 5.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>以上有点过于自我思考,回到官网的Guide吧。</p>
<h2><span id="完全的重新学习">完全的重新学习：</span></h2><p><strong>最基础的指令</strong>： v-bind(简写”:”）,v-on(简写”@”),v-model,v-if,v-for</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">       &lt;span :title&#x3D;&quot;message&quot;&gt;Hover me and see what happen!&lt;&#x2F;span&gt; &lt;!--v-bind--&gt;</span><br><span class="line">       </span><br><span class="line">       &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt; &lt;!--v-model--&gt;</span><br><span class="line">       &lt;input v-model&#x3D;&quot;message&quot; &gt;</span><br><span class="line">       </span><br><span class="line">       &lt;div v-if&#x3D;&quot;seen&quot;&gt;v-if demo: can you see me ?&lt;&#x2F;div&gt;  &lt;!--v-if--&gt;</span><br><span class="line">       &lt;button @click&#x3D;&quot;toggleVisible&quot;&gt;toggle visibility&lt;&#x2F;button&gt;</span><br><span class="line">       </span><br><span class="line">       &lt;div v-for&#x3D;&quot;book in books&quot; :key&#x3D;&quot;book.id&quot;&gt;  &lt;!--v-for--&gt;</span><br><span class="line">           &#123;&#123; book.id &#125;&#125;、&#123;&#123;book.name&#125;&#125;</span><br><span class="line">       &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default&#123;</span><br><span class="line">        name:&quot;Directives&quot;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                message:&#39;This is a message from Vue instance!&#39;,</span><br><span class="line">                seen:true,</span><br><span class="line">                books:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        id:1,</span><br><span class="line">                        name:&#39;YDKJSY&#39;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        id:2,</span><br><span class="line">                        name:&#39;Functional Programming&#39;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            toggleVisible()&#123;</span><br><span class="line">                this.seen &#x3D; !this.seen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#x2F;&#x2F;小思考：data是个方法，返回一个对象；其它OptionsAPI是个键值对</span><br><span class="line">        &#x2F;&#x2F;箭头函数返回对象是()&#x3D;&gt;(&#123;&#125;),data()&#x3D;&gt;(&#123;&#125;)这样可以吗？不可以。</span><br><span class="line">        &#x2F;&#x2F;Options Property或回调里面不要用箭头函数, this的指向很可能会出错(...)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;v-for用的key最好是循环数组对象里面的东西，不建议使用v-for的第二个参数index</span><br><span class="line">        &#x2F;&#x2F;不用key ESLint会警告</span><br><span class="line">        &#x2F;&#x2F;直接用双引号好不习惯..v-for&#x3D;&quot;book in books&quot;,模板编译时还要用字符串方法提取in</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>创建组件</strong></p>
<p>官网的例子直接在main.js里创建.实际大部分是用单文件组件吧?</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line">app.component(<span class="string">'todo-item'</span>,&#123;</span><br><span class="line">    props:[<span class="string">'todo'</span>],   <span class="comment">//可以添加类型判断吗?还是规定的字符串数组?</span></span><br><span class="line">    template:<span class="string">`&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li`</span>       <span class="comment">//很好的解释了什么叫模板字符串</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Vue’s component syntax is loosely modeled after the Web Component Spec.</p>
<p>参数跟原生的docuement.createElement很像.</p>
<p>原生API的升级版: 兼容性更强,功能也更多.</p>
<p>内部实现其实两者没有联系,只是参数看起来像</p>
</blockquote>
</li>
</ul>
<hr>
<p><code>createApp()</code>和mount(‘#root’)返回的东西是不一样的.前者返回应用实例,后者返回根组件实例.(整棵树和根节点的区别?前者整棵树,后者只有根这个单一组件节点)</p>
<p>正因<code>createApp()</code>返回的是应用实例,所以它可以被链式调用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.createApp(RootComponent)</span><br><span class="line">   .component(<span class="string">'SearchInput'</span>, SearchInputComponent)</span><br><span class="line">   .directive(<span class="string">'focus'</span>, FocusDirective)</span><br><span class="line">   .use(LocalePlugin)</span><br></pre></td></tr></table></figure>

<p>渲染一次之后就不再改变,v-once.使用该指令的元素, <strong>绑定的所有值</strong>都只会渲染一次.v-model也没用.(控制显示而不控制实际变化)</p>
<p>将data里的html元素<strong>解析</strong>出来,v-html. &lt;span style=”color:red”&gt;rawHtml&lt;/span&gt;</p>
<p>在v-html里的数据绑定是不会生效的.动态使用这个要注意XSS攻击</p>
<p><strong>给元素绑定一个undefined或null的属性,结果是那个属性不会出现在DOM上; 不像react里给个属性名默认就为true</strong></p>
<hr>
<p>A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes.</p>
<p>指令的作用是当对应表达式的值改变时,对DOM产生一些副作用.</p>
<p>一些指令可以认为是传一些”参数”给它, 比如v-bind:href , v-on:click, 这里的href和click.</p>
<p>动态参数就是用[attrName]或者[eventName]代替这里的href和click,从而给DOM绑定不同的属性,不同的事件才触发函数.<strong>attrName或eventName解析出来是null就不会绑定相应属性/事件,解析出来的必须是字符串</strong>,如果复杂的话可以用计算属性代替而不是直接在template里面计算,而且在template的属性里能用到的全局对象数量也会受到限制.</p>
<p>修饰符, 就是给事件绑定添加一些另外的特性,比如 .prevent,就会绑定事件,触发事件后调用event.preventDefault()</p>
<hr>
<p>OptionsAPI里的data是个函数,需要返回一个对象.</p>
<p><strong>一些不确定值的属性你可以把它提前设置为null或undefined,你后面直接加数据到Vue实例上,它是没有响应性的. vm.$set()解决</strong></p>
<p>$ 是Vue的内部方法标识, _ 是内部属性标识.</p>
<p>computed和methods直接用在template里面有什么区别?computed更多是简单计算,methods更多是复杂操作?</p>
<p>methods里不要有任何副作用,比如改变data或者触发异步任务(???)</p>
<p><strong>防抖节流</strong>: Vue里面没有具体实现,可以用loadsh,把防抖节流方法挂载app上,那么这个事件在整个app中都会有了.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;lodash@4.17.20&#x2F;lodash.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  Vue.createApp(&#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">      &#x2F;&#x2F; Debouncing with Lodash</span><br><span class="line">      click: _.debounce(function() &#123;</span><br><span class="line">        &#x2F;&#x2F; ... respond to click ...</span><br><span class="line">      &#125;, 500)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).mount(&#39;#app&#39;);</span><br><span class="line">    &#x2F;&#x2F;组件如果要有自己的节流防抖,那在该组件的created里添加相同事件来覆盖这个全局方法</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>为什么要有computed计算属性? 一是直接在template里用计算表达式可读性太差了;二是,如果这个表达式要用很多次呢?用很多次也还是不直观.</p>
<p>computed里依赖的收集是底层实现的(自己运算了一遍,找出对应的依赖项),不用像useEffect一样显式声明.</p>
<p>跟methods相比, computed更像useEffect,后者是一个自动填写第二个参数的useEffect。</p>
<p>React的话语是依赖项没有变化，Vue的话语意图更多是将计算结果“缓存”起来。表现是差不多的。</p>
<p>典型的差异是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    computed:&#123;</span><br><span class="line">        now()&#123;</span><br><span class="line">          return new Date();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        now()&#123;</span><br><span class="line">            return new Date();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#x2F;&#x2F;前者不会改变，因为Date对象不是响应式的；后者会变，每次调用都是新的函数执行。</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>计算属性传个函数，那这个函数默认是getter,直接return某个值。</p>
<p>你也可以显式的声明getter和setter.在设置这个计算属性时，对其它一些属性进行操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   export default&#123;</span><br><span class="line">       computed:&#123;</span><br><span class="line">           fullName()&#123;</span><br><span class="line">               getter()&#123;</span><br><span class="line">                   return this.firstName + &#39; &#39; + this.lastName; </span><br><span class="line">               &#125;,</span><br><span class="line">               setter(newVal)&#123;</span><br><span class="line">                   const newName &#x3D; newVal.split(&#39; &#39;);</span><br><span class="line">                   this.firstName &#x3D; newName[0];</span><br><span class="line">                   this.lastName &#x3D; newName[1];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Though computed property are appropriate in most cases, but it is more useful when you want to <em>perform asynchronorous or expensive operations</em> when data are changed.</strong></p>
<p>异步或者繁琐的操作，还是交给watch更好。</p>
<p>watch是真正的一对一监控，参数分别是新值和旧值。watch的选项呢？deep,immediate?还有呢？ //TODO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   export default&#123;</span><br><span class="line">       data()&#123;</span><br><span class="line">           return &#123;</span><br><span class="line">               beingWatched:0</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       watch:&#123;</span><br><span class="line">           beingWatched(newVal,oldVal)&#123;</span><br><span class="line">               &#x2F;&#x2F;some async or expensive operations</span><br><span class="line">               &#x2F;&#x2F;deep? immediate?</span><br><span class="line">               console.log(newVal,oldVal);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>watch能做的，computed也能做，而且多数情况下，后者可能会更好。</p>
<hr>
<p>绑定类和样式</p>
<p>对象形式的话，根据值的真假，决定是否添加这个类/样式(?);数组形式的话，是类的别名（？这有什么用？）;</p>
<p>前者条件添加类/样式，后者动态修改类/样式。(?)</p>
<p>你甚至可以两者一起用，将对象形式混到数组形式中去。</p>
<p>来来回回就是数组和对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;[isActive?activeClass:null ,errorClass]&quot;&gt;</span><br><span class="line">        abcd</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div :class&#x3D;&quot;[&#123; active: isActive&#125;, errorClass]&quot;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   export default&#123;</span><br><span class="line">       data()&#123;</span><br><span class="line">           return &#123;</span><br><span class="line">               activeClass:&#39;active&#39;,</span><br><span class="line">               errorClass:&#39;text-danger&#39;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注册组件时添加的类，不会在具体使用的时候因再次绑定class而消失. ？</strong></p>
<p><strong>问题1：will not be overwritten? 原有的和使用时绑定的重名了呢?</strong></p>
<p>插曲: $attrs是标签的自带属性，比如title,href等。$props更多是自定义属性，与标签本身无关。</p>
<p>绑定样式最好直接绑定个data里的对象，或者用数组绑定多个对象，又简洁又不失可读性.既然用到对象，属性名自然是驼峰而不是纯CSS的横杠连接了。fontSize: ‘16px’。</p>
<p>内部优化： 一些需要添加前缀才能兼容的属性，比如transform，Vue会自动检测出来并添加进去。尤大牛B。</p>
<p><strong>问题2：样式数组对象按顺序覆盖吗？</strong></p>
<hr>
<p><strong>条件渲染</strong></p>
<p>v-if,v-else,v-else-if</p>
<p>内部是怎么找到对应的？ 比如后面有else，怎么v-if在哪个元素上？额。v-if,v-else必须连用…</p>
<p>个人认为，条件渲染中React更好理解。v-if必须只能挂在一个元素上。那么要条件渲染两个或多个同级的元素时很难实现，要么逐一挂同一个v-if，要么直接抽离，挂在template上。这种情况是否直接写render function更好呢？</p>
<p>而JSX有空元素充当根节点，条件渲染同级元素可能会更容易。</p>
<p>v-show算条件渲染吗？严格意义上不算，它有被渲染，不过display属性被设置成了none.</p>
<p><strong>而且，它不能被用在&lt;template&gt;元素上，也不能代替v-if，跟v-else连用。</strong></p>
<p>使用场景：</p>
<blockquote>
<p><code>v-if</code> has higher toggle costs while <code>v-show</code> has higher initial render costs.So prefer <code>v-show</code> if you need to toggle something very often, and prefer <code>v-if</code> if the condition is unlikely to change.</p>
</blockquote>
<p><strong>v-if和v-for尽量不要一起用。真一起了，v-if优先</strong></p>
<hr>
<p>列表渲染：v-for</p>
<p>你可以v-for=”(value,key,index) in items” , 也可以用v-for=”item of items”</p>
<p>原生JS中，in的迭代器keys, of的迭代器时entries. 这里的in直接跟JS语法没有关系，属于Vue特性一种。</p>
<p><strong>内部怎么解析实现的in和of?</strong></p>
<p>Object is not iterable, <code>of</code> can only be used on iterable values.</p>
<p><em>key的作用（1）</em></p>
<p>v-for一样有key这个问题： 不加key,原地复用，1、2、3删2，剩下的是1、2；  加了key，1、2、3删2，剩下1、3</p>
<p>准确删除和顶替删除的区别。</p>
<p>足够简单或者就是想顶替删除这种表现，可以不加key(ESLint这关能过吗？)</p>
<p>由于v-if的优先级比v-for高，所以v-if是访问不了v-for的作用域的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; &lt;!--这样是无效的--&gt;</span><br><span class="line">    &lt;li v-for&#x3D;“item in items&quot; v-if&#x3D;&quot;item.isComplete&quot;&gt;</span><br><span class="line">       &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;!--这样才行--&gt;</span><br><span class="line">&lt;template v-for&#x3D;&quot;item in items&quot;&gt;</span><br><span class="line">    &lt;li v-if&#x3D;&quot;item.isComplete&quot;&gt;</span><br><span class="line">    &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>直接将v-for用在自定义组件上，比如&lt;my-com v-for=”(item,index) in items” /&gt;，这样item是不会有东西的。</p>
<p>你要把item,index,key等等作为props传给子组件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!--item是什么东西?不是应该items吗？！确实不应该。不过子组件知道item和index是什么东西吗？--&gt;</span><br><span class="line">   &lt;my-com</span><br><span class="line">           v-for&#x3D;&quot;(item,index) in items&quot;  </span><br><span class="line">           :item&#x3D;&quot;item&quot;</span><br><span class="line">           :index&#x3D;&quot;index&quot;</span><br><span class="line">           :key&#x3D;&quot;item.id&quot;</span><br><span class="line">           &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>事件: v-on:, @, 拿原生事件就在绑定的时候传个特殊参数$event</p>
<p>怎么同一元素绑定多个事件? </p>
<p>直接逗号隔开(!?这模板解析也太强了)</p>
<p>事件修饰符：</p>
<ol>
<li>.stop 2. .prevent 3. .capture 4. .self 5. once 6. .passive 7. .number 8.lazy 9. .native 10. .trim</li>
</ol>
<p>不熟悉的有: capture, self , once ,passive</p>
<p>capture： 原先由里到外处理事件， 用了capture后由外到里处理事件；</p>
<p>self：触发事件的仅当是元素自身才触发，子组件触发这个事件，父组件不会理会</p>
<p>once: 只执行一次</p>
<p>passive:立即执行事件而不是等待事件执行被结束？什么意思？对于手机用户体验提升巨大？不要跟.prevent连用</p>
<p>lazy: 类似validateTrigger=’onBlur’,失去焦点或按下enter时才更新实例数据</p>
<p>exact：精准匹配按钮</p>
<p>键盘：^&amp;*()，keyup,keydown, .ctrl, .delete    …</p>
<p>鼠标: .left, .right, .middle</p>
<p><strong>修饰符可以链式调用，所以这样用时，修饰符的顺序影响实际表现</strong></p>
<p>比如: @click.self.prevent 仅阻止自身点击， 而@click.prevent.self阻止所有的点击（？具体没理解到，但直到顺序是有影响的。）</p>
<p>可以用在特定按键绑定： @click.ctrl=”onPress” </p>
<hr>
<p>组件：</p>
<p>监听子组件的事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;button @click&#x3D;&quot;$emit(&#39;trigger&#39;,&#39;content&#39;)&quot;&gt;</span><br><span class="line">       Try it out!</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Parent.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;child-component @trigger&#x3D;&quot;parentMethod&quot;&gt;&lt;&#x2F;child-component&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import Son from &#39;.&#x2F;components&#x2F;Son.vue&#39;;</span><br><span class="line">   export default&#123;</span><br><span class="line">       components:&#123;</span><br><span class="line">           &#39;child-component&#39;:Son</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           parentMethod(arg)&#123;</span><br><span class="line">               console.log(arg);</span><br><span class="line">               &#x2F;&#x2F;console.log(argObject.a,argObject.b)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件要向父组件传多个参数时，要把它裹在一个对象里面，由父组件处理。</p>
<p>$emit方法的第二个参数更像call而不是apply</p>
<p>父组件要给子组件实现双向绑定，要把绑定的值传给子组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接使用的v-model, under the hood</span><br><span class="line">&lt;template&gt;</span><br><span class="line">      &lt;input v-model&#x3D;&#39;someValue&#39; &gt;</span><br><span class="line">      &lt;input :value&#x3D;&#39;someValue&#39; @input&#x3D;&#39;someValue &#x3D; $event.target.value&#39; &gt;</span><br><span class="line">      &lt;!--指令内全是字符串也能解析出来..--&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用在子组件的时候:      (Useful as hell)</span><br><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;child-component</span><br><span class="line">       :model-value&#x3D;&#39;parentVal&#39;</span><br><span class="line">       @update:model-value&#x3D;&#39;parentVal &#x3D; $event&#39;&gt;</span><br><span class="line">    &lt;&#x2F;child-component&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>也可以用计算属性来实现子组件的双向绑定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;input v-model&#x3D;&#39;selfValue&#39; &gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   export default&#123;</span><br><span class="line">       props:[&#39;valueFromParent&#39;],</span><br><span class="line">       computed:&#123;</span><br><span class="line">           value()&#123;</span><br><span class="line">              get()&#123;</span><br><span class="line">                  return this.valueFromParent;</span><br><span class="line">              &#125;,</span><br><span class="line">              set(newVal)&#123;</span><br><span class="line">                  this.$emit(&#39;update:modelValue&#39;,newVal);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>:is可以用来实现动态组件,而且像ul, table,select这些子元素是规定的，可以用它来避免错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;ul&gt;</span><br><span class="line">       &lt;my-component &#x2F;&gt;     &lt;!--这里虽然my-component实际可能是&lt;li&gt;,但也会报错--&gt;</span><br><span class="line">       &lt;li v-is&#x3D;&quot;&#39;my-component&#39;&quot;&gt;&lt;&#x2F;li&gt; &lt;!--这才是正确的，内部要么是**字符串**，要么是实例对象--&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>Components Basics的Parsing Caveats 还有部分不清楚.   //TODO 问题三</p>
<hr>
<p>注册组件： globally and locally. 最好全小写，用横杠-分开(hyphen),</p>
<p>非全局注册组件时，用首字母大写(PascalCase)命名组件，在template里面也可以用kebab-case指向相同组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">   MyComponent</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;template</span><br><span class="line">&lt;my-component &#x2F;&gt;   &lt;!-- it&#39;s ok --&gt;</span><br></pre></td></tr></table></figure>

<p>全局注册就是app.component(‘component-a’, { DEFINITION });  最好只在一个地方使用，否则到处全局注册很难找定义。</p>
<p>局部注册，直接const componentName = { data… methods … };(template和props这些也在这定义吗?问题四)原文是直接将Options Object给这个componentName.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">app.component(&#39;my-component&#39;, &#123; &#x2F;** ... **&#x2F; &#125;);</span><br><span class="line">&#x2F;&#x2F;局部注册的分两种: 在同一文件内定义， 一个文件一个组件SFC</span><br><span class="line">&#x2F;&#x2F;1.同一文件内:</span><br><span class="line">const componentA &#x3D; &#123;</span><br><span class="line">   data()&#123;</span><br><span class="line">     return &#123;&#125;;</span><br><span class="line">   &#125;,</span><br><span class="line">    template:&#96;&lt;div&gt;Hello&lt;&#x2F;div&gt;&#96;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;!--2.不同文件内（并不是, import实现依赖Babel或Webpack，但实际用种方法多）--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F;ComponentB.vue</span><br><span class="line">    export default&#123;</span><br><span class="line">        name:&#39;ComponentB&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   &#x2F;&#x2F;Parent.vue</span><br><span class="line">   import ComponentB from &#39;.&#x2F;components&#x2F;ComponentB.vue&#39;;</span><br><span class="line">   export default &#123;</span><br><span class="line">       name:&#39;Parent&#39;,</span><br><span class="line">       components:&#123;</span><br><span class="line">           ComponentB</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>Props： 字符串数组，或者对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component :likes&#x3D;&quot;42&quot; is-published&#x2F;&gt; </span><br><span class="line">&lt;!--虽然是数字，但也要v-bind,告诉Vue这是表达式而不是字符串,布尔值同理(?!);没有值的，默认拿到true--&gt;</span><br></pre></td></tr></table></figure>

<p><strong>传props除了想缩写，省略true的（类似上面的is-published)，其它都要用v-bind，无论用的是否为Vue实例里的东西。</strong></p>
<p>整个对象传下去，可以直接 :objectName,      会被解构成多个属性绑定到在那个组件上.</p>
<p>Time to play around~</p>
<p><strong>不要直接修改props！不要直接修改props！不要直接修改props！</strong></p>
<p>用computed，或者data重新起一个新属性！（Derived Properties）</p>
<p>值传递的问题：props如果是原始值(Primitive Type)还好，传了给子组件，修改就修改了，只会警告；而如果是引用类型(Reference Type)的，好家伙，直接把父组件的也改了 (👍）。</p>
<p><strong>props的校验在实例被创建前就进行了，所以实例的任何东西都是访问不到的.(问题：具体时机呢?beforeCreate?)</strong></p>
<p>null和undefined会通过所有的props type checks,如果没有required的话，甚至没有警告?(Try it out!)</p>
<p>（过于高级，甚至不懂怎么用）： 校验甚至可以是一个构造函数，用instanceof来判断props是否某一构造函数的实例。（问题：在哪定义的这个构造函数？接受props的组件吗？）</p>
<p><strong>！！！用in-DOM Template的，props是camelCase的，template里会被转成kebab-case！！！</strong>(String Template不会这样)</p>
<p>问题：哪个才是in-DOM template?全局注册的那个吗？还是vue文件那个？</p>
<hr>
<p>Non-Props Attributes，</p>
<p>父组件传一个子组件没有在props里声明的东西，子组件可以从$attrs拿到，而且这个东西会自动给到子组件的根元素。（Attributes Inheritance) (emit也是一样的，不过没有props好理解，一个针对属性，一个针对事件)</p>
<p>怎么禁用呢？跟data同级，inheritAttrs：false。（一般是不想直接给根元素，而是给到子组件的另外元素）</p>
<p>当组件根节点是多个，那么你要至少一个绑定$attrs,否则会警告.</p>
<hr>
<p>自定义事件：</p>
<p><strong>Always use kebab-case for event names</strong></p>
<p>emits定义一个原生事件（自定义和原生撞车），用的是<strong>自定义的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F;和props有validator一样，emits也可以校验传参是否合法。</span><br><span class="line">&#x2F;&#x2F;全局注册组件时，props和emits在教程的最开始，都是字符串数组.(Help to recall)</span><br><span class="line">    app.component(&#39;custom-form&#39;,&#123;</span><br><span class="line">        emits:&#123;</span><br><span class="line">           submit: (&#123; name, pwd &#125;)&#x3D;&gt;&#123;</span><br><span class="line">               if(name &amp;&amp; pwd)&#123;</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   console.log(&#39;Please input&#39;);</span><br><span class="line">                   return false;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>父组件可以给子组件使用多个v-model实现双向绑定，如果不显式说明，默认会用modelValue作为绑定值，update:modelValue作为事件名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;user-name</span><br><span class="line">             v-model:first-name&#x3D;&quot;firstName&quot;</span><br><span class="line">             v-model:last-name&#x3D;&quot;lastName&quot;</span><br><span class="line">             &gt;</span><br><span class="line">    &lt;&#x2F;user-name&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  const app &#x3D; Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  app.component(&#39;user-name&#39;, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    firstName: String,</span><br><span class="line">    lastName: String</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;input </span><br><span class="line">      type&#x3D;&quot;text&quot;</span><br><span class="line">      :value&#x3D;&quot;firstName&quot;</span><br><span class="line">      @input&#x3D;&quot;$emit(&#39;update:firstName&#39;, $event.target.value)&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input</span><br><span class="line">      type&#x3D;&quot;text&quot;</span><br><span class="line">      :value&#x3D;&quot;lastName&quot;</span><br><span class="line">      @input&#x3D;&quot;$emit(&#39;update:lastName&#39;, $event.target.value)&quot;&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>问题：　自定义修饰符不太懂，capitalize为什么会是true?传的明明是bar?</p>
<hr>
<p>Slot 插槽,</p>
<p>匿名插槽:</p>
<p>子元素以插槽的方式接收来自父组件的内容(这里指DOM而不单是数据)</p>
<p>既然是父传子收,那传的当然就是父组件的东西啦~这里指匿名和具名插槽,区别于作用域插槽.</p>
<blockquote>
<p>Everything in the parent template is compiled in parent scope; everthing in the child template is compiled in the child scope.</p>
</blockquote>
<p>你不用slot接收,父组件就白传啦<del>你用了slot,父组件没传(欸</del>)slot里的内容就会被渲染啦~</p>
<p>slot这东西,传了就用,不传就用自己的.</p>
<p>具名插槽, 写明name属性, 不写默认name=”default”.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Son.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;header&gt;</span><br><span class="line">    &lt;slot name&#x3D;&#39;header&#39;&gt;&lt;&#x2F;slot&gt;      &lt;!--key 1--&gt;</span><br><span class="line">   &lt;&#x2F;header&gt;</span><br><span class="line">   &lt;main&gt;</span><br><span class="line">     &lt;slot name&#x3D;&#39;content&#39;&gt;&lt;&#x2F;slot&gt; </span><br><span class="line">   &lt;&#x2F;main&gt;</span><br><span class="line">   &lt;footer&gt;</span><br><span class="line">     &lt;slot name&#x3D;&#39;bottom&#39;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">    &lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Parent.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;son-component&gt;                 &lt;!--key 2--&gt;</span><br><span class="line">     &lt;template v-slot:header&gt;     &lt;!--key 3--&gt;    </span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">          Header</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">     &lt;&#x2F;template&gt;</span><br><span class="line">     &lt;template v-slot:content&gt;</span><br><span class="line">         This is Content.</span><br><span class="line">     &lt;&#x2F;template&gt;</span><br><span class="line">     &lt;template v-slot:bottom&gt;</span><br><span class="line">         This is footer.</span><br><span class="line">     &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;son-component&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>子组件slot + name , 父组件, 子组件元素内,template + v-slot:name</p>
<p><strong>作用域插槽</strong></p>
<p>数据在子组件里,又想经过父组件改装一下这些数据并展示出来.</p>
<blockquote>
<p>We might want to replace the slot to customize it on the parent component.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;child.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">     &lt;li v-for&#x3D;&quot;(item,index) in items&quot;&gt;</span><br><span class="line">      &lt;slot :item&#x3D;&quot;item&quot;&gt;&lt;&#x2F;slot&gt;      &lt;!--key 1:将item作为props传给slot--&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;parent.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;son &gt;</span><br><span class="line">       &lt;template v-slot:default&#x3D;&quot;slotProps&quot;&gt;</span><br><span class="line">       &lt;!--这里没有用到name属性,所以更多关注slotProps,这个名字是自定义的--&gt;</span><br><span class="line">           &lt;span class&#x3D;&quot;green&quot;&gt;&#123;&#123; slotProps.item &#125;&#125; &lt;&#x2F;span&gt;</span><br><span class="line">       &lt;!--作为对象,将绑定到slot的props统一传给父组件--&gt;</span><br><span class="line">       &lt;&#x2F;template&gt;</span><br><span class="line">    &lt;&#x2F;son&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>把内容全部分发给匿名插槽时,你可以把v-slot直接挂载组件上而不用多写一个template.甚至直接把default也省略了吧.</p>
<p>不过你要么直接v-slot=”slotProps”,要么v-slot:default=”slotProps”,不要两个一起用,会混淆作用域.</p>
<p><strong>在父组件中,你拿到的slotProps(自定义的对象名)实际就是个函数的参数(arguements), 你可以将它解构,重命名,甚至赋默认值</strong></p>
<p>支持动态的插槽名称 &lt;template v-slot:[dynamicSlotName]&gt;(问题:这里不用v-bind了?直接就是data里的吗?)</p>
<p>缩写是# , #default=”{ item }”  等价于 &lt;todo-list v-slot:default=”{ item }”&gt; ( 我摊牌了,slotProps都懒得起名了,直接解构) </p>
<p>(不能直接#=”{item}”, 匿名插槽也要写上name这个属性传给#这个函数(?).把指令看成函数没问题吧?)</p>
<p>#header, #main, #footer就是具名插槽,没有到作用域插槽.</p>
<p>具名插槽和作用域插槽是可以一起出现的!  (匿名/具名插槽一组,        作用域插槽自己一组);</p>
<hr>
<p>Provide/ Inject , 跨级传props, 不过不用知道由谁provide, 有谁会inject.</p>
<ul>
<li><p>直接provide实例的数据是不行的，因为内部先实现provide再初始化实例的data。</p>
<p>如果要provide实例的数据，要用函数返回一个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> export default&#123;</span><br><span class="line">     data()&#123;</span><br><span class="line">         value:1</span><br><span class="line">     &#125;,</span><br><span class="line">     provide()&#123;</span><br><span class="line">      return &#123;</span><br><span class="line">          value: this.value</span><br><span class="line">      &#125;   </span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;直接返回非实例的数据:</span><br><span class="line">     &#x2F;&#x2F;provide:&#123;</span><br><span class="line">     &#x2F;&#x2F; user: &#39;John&#39;</span><br><span class="line">     &#x2F;&#x2F;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>provide实例的数据，它不是响应式的。（默认行为。问题：为什么不把provide处理成reactive呢？）</p>
<p>要用ref / reactive 或者computed 对数据进行包裹（返回一个用ref/reactive包裹的对象，或者单一属性的话，直接用computed进行包裹.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">provide()&#123;</span><br><span class="line">   return &#123;</span><br><span class="line">     todoLength: Vue.computed(() &#x3D;&gt; todo.length);</span><br><span class="line">   &#125;;</span><br><span class="line"> &#x2F;&#x2F; return ref(&#123;          &#x2F;&#x2F;这样吗？</span><br><span class="line"> &#x2F;&#x2F;   todo: todo.length,</span><br><span class="line"> &#x2F;&#x2F;   somthing: something.a        </span><br><span class="line"> &#x2F;&#x2F;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>动态组件， :is做了一个tabs-list,但切换的时候没有保持之前的状态, 所以要用&lt;keep-alive&gt;维持组件的状态.否则每次切换回来都会创建新的组件实例.</p>
<p>异步组件, defineAsyncComponent</p>
<blockquote>
<p>Promise’ <code>resolve</code> callback should be called when you have retrieved your component definition from the server.</p>
</blockquote>
<p>组件的定义从服务器中返回?返回来了才进行注册?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    const app &#x3D; Vue.createApp(&#123;&#125;);</span><br><span class="line">    const AsyncComp &#x3D; Vue.defineAsyncComponent(</span><br><span class="line">     () &#x3D;&gt; new Promise((resolve,reject))&#123;</span><br><span class="line">        resolve(&#123;</span><br><span class="line">         template:&#39;I am async! And I\&#39;m server&#39;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F;if(condition)reject(reason)  &#x2F;&#x2F;try...catch...mix them in</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;或者用Webpack&#x2F; ES2015</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123; defineAsyncComponent &#125; from &#39;vue&#39;;</span><br><span class="line">    const AsyncComponent &#x3D; defineAsyncComponent(&#123;</span><br><span class="line">        import(&#39;.&#x2F;components&#x2F;AsyncComponent.vue&#39;)</span><br><span class="line">    &#125;);</span><br><span class="line">    app.component(&#39;async-com&#39;,AsyncComponent);</span><br><span class="line">    components:&#123;</span><br><span class="line">        &#39;async-com&#39;: defineAsyncComponent(()&#x3D;&gt;</span><br><span class="line">          import(&#39;.&#x2F;components&#x2F;AsyncComponent.vue&#39;)</span><br><span class="line">     )</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用defineAsyncComponent和&lt;Suspense&gt;作用是一致的.如果定义时用了Suspense来包裹组件,你可以在option里面用suspensible:false来控制它的加载状况.</p>
<p>(?suspense包裹了为什么还要suspensible:false? 疑惑?)</p>
</li>
</ul>
<hr>
<p>refs,直接拿到某个元素.</p>
<ul>
<li>不要在template利用用$refs, DOM都挂载好了这个属性才会有值.</li>
<li>vue2里面直接给元素加个ref属性,然后OptionsAPI里就可以this.$refs.xxx了.(时机至少是mounted.)</li>
<li>vue3里创建个空ref, //TODO 问题</li>
</ul>
<hr>
<p>Edge Cases: Forcing updates and prevent UNNACESSARY updates.</p>
<p>$forceUpdate(问题: 实现原理) v-once. Try not to use them unless you falls into those rare use cases.</p>
<hr>
<p>先跳过动画.理解一些可能用到的概念先:</p>
<p>Reusability &amp; Composition</p>
<p>Mixin, 将另外的Options Object 混入到当前的实例</p>
<ul>
<li>数据冲突时,** 实例内的优先级高**</li>
<li>生命周期, 放在一个数组内,先执行混入进来的先,再执行实例本身的.</li>
<li>Options 是对象的,比如methods,computed(区别于data或provide是函数),会合并成一个对象.实例内的优先级高.(问题:用的什么策略合并?手写的深拷贝吗?Object.assign肯定是不行的.)</li>
</ul>
<p>全局混入,app.mixin({options}); 谨慎使用.整个应用每个组件都会受到影响.可以用Plugins来代替这个功能.</p>
<p>改变混入策略,在全局中加个函数,针对某个混入值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是默认的行为,custom这个属性,用实例自身而不是混入进来的.</span></span><br><span class="line">app.config.optionMergeStrategies.custom = <span class="function">(<span class="params">toVal,fromVal</span>) =&gt;</span> fromVal || toVal;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是修改后的行为,用混入进来的而不是实例本身的</span></span><br><span class="line">app.config.optionMergeStrategies.custom = <span class="function">(<span class="params">toVal,fromVal</span>) =&gt;</span> toVal || fromVal;</span><br></pre></td></tr></table></figure>

<p>Cautions:</p>
<ol>
<li>大杂烩,你要知道混了些什么进来,哪个变量方法可能会被覆盖或重名.</li>
<li>可重用性差,混了就混了,不能选择的混,不能函数式的混</li>
</ol>
<p>——&gt; Solution: Composition API~</p>
<hr>
<p>自定义指令</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局注册</span></span><br><span class="line">app.directives(<span class="string">'focus'</span>,&#123;</span><br><span class="line">    mounted(el)&#123;</span><br><span class="line">        el.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部注册</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    directives:&#123;</span><br><span class="line">        focus:&#123;</span><br><span class="line">            mounted(el)&#123;</span><br><span class="line">                el.focus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;input v-focus /&gt;</span><br></pre></td></tr></table></figure>

<p>指令有指令自己的生命周期, beforeMount,mounted,beforeUpdate,updated,beforeUnmount,unmounted</p>
<p>问题: checkout the parameters for each hook.(<a href="https://v3.vuejs.org/api/application-api.html#directive" target="_blank" rel="noopener">指路</a>) </p>
<p>粗略: el ,binding(对象,很多属性) , vNode,  prevNode(仅beforeUpdate和updated有这个属性)</p>
<p>el使用了指令的元素.</p>
<p>binding.instance,      使用该指令的组件实例,跟el不同(废话). (问题:一个组件所有的自定义指令这个值都相同吗?Try it out! 一个组件两个自定义指令,分别读取它的binding.instance)</p>
<p>binding.value, 双引号里的值. v-slot:default=”slotProps”,这里的slotProps</p>
<img src="/.com//Users\lwj\Desktop\Hexo\source\_posts\binding-value.png">

<p>binding.oldValue,(仅beforeUpdate和updated有这个属性)</p>
<p>binding.arg,  v-slot:default=”slotProps”, 这里的default.可以是动态的[something]</p>
<p><img src="/.com//C:%5CUsers%5Clwj%5CDesktop%5CHexo%5Csource_posts%5Cbindg-arg.png" alt="bindg-arg"></p>
<p>binding.modifiers,指令修饰符 </p>
<p>binding.dir, 指令自身描述,类似函数拿到自身定义</p>
<ul>
<li>app.directives()第二个参数传个函数, 默认在mounted和updated两个hooks里执行.(合理!)</li>
</ul>
<p>Vue3中,由于根节点可以多个,自定义指令可能会有丢丢问题?(问题是我完全看不懂…单词都会连起来怎么就不会了?)</p>
<hr>
<p>watchEffect, watch, { flush: ‘sync’/‘pre’/‘post’}</p>
<p>Vue不允许直接添加在实例外往data内新增属性. <strong>Vue.set也不可以</strong></p>
<p>Vue.set是在data里已有的某个对象,添加可响应式的属性.<strong>前提是已存在某个对象</strong></p>
<p>所以,提前将要新增的数据放在data里面,尽管值是null或者undefined.(别管有没有值,reactive了再说)</p>
<p><code>this.$set(this.someObject,propertyName,value)</code></p>
<p>同时往某个对象添加多个属性</p>
<p><code>this.someObject = Object.assign({} , this.someObject, { a:1, b:2});</code></p>
<p>注意是赋给了一个新的对象地址</p>
<p><strong>数组, 1.直接通过索引改值是检测不到的; 2.直接改数组长度也检测不到</strong></p>
<p>第一个可以用Vue.set(vm.arr,indexOfItem,value);或者vm.items.splice(indexOfItem,1,value);</p>
<p>第二个可以vm.items.splice(newLength);</p>
<p>用splice肯定可以规避数组的caveats.</p>
<p>回调形式的$nextTick比async await形式的$nextTick更好理解</p>
<hr>
<p>Teleport起有部分内容要消化, 明天再看一遍.</p>
<p>Composition API另起一篇文章吧~</p>
<p>TO BE CONTINUED~</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

