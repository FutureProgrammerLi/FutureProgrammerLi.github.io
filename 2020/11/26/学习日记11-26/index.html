<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Future Li">
  <!-- Open Graph Data -->
  <meta property="og:title" content="学习日记11-26"/>
  <meta property="og:description" content="Hello World!" />
  <meta property="og:site_name" content="CodingLiveLi"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="CodingLiveLi" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>CodingLiveLi</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">学习日记11-26</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/FutureProgrammerLi" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:617612567@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Future Li</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-11-26</span>
            <span class="time">22:05:52</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Javascript/">Javascript</a> / <a href="/categories/Javascript/Vue/">Vue</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/%E6%97%A5%E8%AE%B0/">#日记</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h2><span id="引言">引言</span></h2><p>  最近发现光看视频，不仅看完觉得自己会了，上手就不会，而且还会很容易困…没错，说的就是functional-light…英语视频一旦没跟上就感觉睡着了一样，就看不懂了。嗨，还有20多P..</p>
<p>  还是边学边码一些感想和学习内容感觉更容易记下来，虽然也不知道自己会不会重新翻看，但起码有了可以复习的内容，不像看视频那样：哦<del>我懂了。两天后，我懂啥了？哦哦哦，就那个，啥？想复习都没根据了。（额，说话全是普通话了。Whatever</del>）</p>
<p>  就记录一下吧，不知道可以持续多久，但~起码维持到找到工作之后吧。</p>
<h2><span id="vue">Vue</span></h2><blockquote>
<p>有了composition API提供的一些函数，是不是就不用vuex了呢？</p>
</blockquote>
<p>先看一个，用provide/inject实现的，类vuex的功能。</p>
<p>问题：</p>
<ol>
<li>vue2也有provide和inject，为什么必须用到了reactive,computed,readonly这些API才能把vuex的部分功能给模拟出来呢？</li>
<li>vuex的模块化怎么用这些API模拟出来？</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, readonly &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> stateSymbol = <span class="built_in">Symbol</span>(<span class="string">'state'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">        counter: <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        state:readonly(state),</span><br><span class="line">        increment</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useState = inject(stateSymbol);</span><br><span class="line"><span class="comment">//./store/index.js</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore, stateSymbol &#125; <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line">app.provide(stateSymbol,createStore());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>直接在app层provide整个store,整个应用都可以共享到这个state了。</p>
</li>
<li><p>stateSymbol意图不明显，为了确保唯一?如果要多个仓库的话如何实现呢？</p>
</li>
<li><p>在createStore里面</p>
<ul>
<li>方法里面，reactive是可以被改变的，只不过在导出的时候才用readonly再次包装。</li>
<li>导出时用readonly，保证了只允许createStore里的方法可以修改这个state，而不是被乱改。</li>
<li>除了reactive和function,还可以用computed模拟vuex的getters,用function/ async function模拟mutations/actions.（还强制actions里调用mutations里的方法吗？没了吧？）</li>
</ul>
</li>
</ul>
<p><strong>重大问题，被包裹了两层。在组件里访问counter,要用state.state.counter,state.increment.</strong> </p>
<p>createStore里包裹成了对象，组件里又被包裹成了对象.</p>
<blockquote>
<p><a href="https://medium.com/better-programming/why-you-might-not-need-vuex-with-vue-3-61ad09e62334" target="_blank" rel="noopener">https://medium.com/better-programming/why-you-might-not-need-vuex-with-vue-3-61ad09e62334</a></p>
<p>原文链接</p>
</blockquote>
<p>其它文章大同小异，主要的API还是provide和inject.</p>
<p>Vuex是否就可以抛弃了呢?并不，它有以下优点:</p>
<ol>
<li>易于调试, mutations are trackable, and time-travel ability is allowed by Dev tools.</li>
<li>插件多. vue-persisted / Vue Router,…etc.不少功能Composition API也能模拟，但没有Vuex这样结构化标准化。</li>
</ol>
<hr>
<blockquote>
<p><a href="https://vueschool.io/articles/vuejs-tutorials/state-management-with-composition-api/" target="_blank" rel="noopener">https://vueschool.io/articles/vuejs-tutorials/state-management-with-composition-api/</a></p>
<p>原文链接</p>
</blockquote>
<p>用ref和computed两个API写一个vuex.</p>
<p>一个亮点是，可以用watch或watchEffect,用数组模拟实现vuex的调试/time travel功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> histroy = [];</span><br><span class="line">watch(state,(newState,oldState)=&gt;&#123;</span><br><span class="line">    history.push(oldState);</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>还有一个，允许自己写的Composition 分享状态而不是每个函数作用域每一次全新的状态。（提升到文件全局就行）</p>
<p>封装一个vuex获取数据的hooks：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed, readonly &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useProduct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> loading = ref(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> products = ref([]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">        loading.value = <span class="literal">true</span>;</span><br><span class="line">        products.value = <span class="keyword">await</span> fetchProducts(params);</span><br><span class="line">        loading.value = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">		loading: computed(<span class="function"><span class="params">()</span> =&gt;</span> loading.value),</span><br><span class="line">        products:computed(<span class="function"><span class="params">()</span> =&gt;</span> products.value),</span><br><span class="line">        search</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//function search(params:Object)=&gt;void</span></span><br></pre></td></tr></table></figure>

<p>computed可以用readonly代替，只是为了不让函数外部的代码修改这里的值.(computed返回的值是不可修改的)</p>
<p>个人认为存在不足:导出的search是否有类型推断？是否需要查看整个hook才能知道它是函数，才能知道它接收的参数是什么？</p>
<p>好处是不会像Vuex那样，没有数据也用空数组或对象先声明出来，而是需要的时候才会创建相应的数据，比如这里的products.</p>
<p>而且这样用，products是互相独立的，每一次的函数调用都会有不同的products(?).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useProduct &#125; <span class="keyword">from</span> <span class="string">'./hooks'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    setup(props,ctx)&#123;</span><br><span class="line">        <span class="keyword">const</span> id = ctx.root.$route.params.id;</span><br><span class="line">        <span class="keyword">const</span> &#123; products, loading, search &#125; = useProduct();</span><br><span class="line">        <span class="keyword">await</span> search(id);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            product: computed(<span class="function"><span class="params">()</span> =&gt;</span> products.value[<span class="number">0</span>]),</span><br><span class="line">            loading</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compositions之间共享数据的两种方法:</p>
<ol>
<li><p>偏向vuex的模式，向外暴露修改状态的方法，通过引入函数的方式在各个compositions里使用。问题是依赖了外部的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = ref(&#123;</span><br><span class="line">    cart:[]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> setCart = <span class="function">(<span class="params">cart</span>) =&gt;</span> &#123; state.value.cart = cart &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; setCart &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//各个hooks内:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCart</span>(<span class="params"></span>)</span>&#123; setCart(&#123; data &#125;); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherCart</span>(<span class="params"></span>)</span>&#123; setCart(&#123; data &#125;); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更好的方法，直接将需要共享的状态提升到外部.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cart = ref(&#123;&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCart</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        cart:computed(<span class="function"><span class="params">()</span> =&gt;</span> cart.value;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2><span id="心得">心得：</span></h2><p>Vuex这种中心状态管理模式真能被取代吗？</p>
<p>如果用函数，向外暴露的方法，状态和方法少的情况下可以优化，但多起来，尤其是Composition API,return出来的东西不就更多了？</p>
<p>而直接显式的表明mutations,actions,我认为并不比vue3的function/async function差。能想到的好处大概是可以把相关的逻辑放在相同的位置，就是原本Composition替代Options那样的思想，不用多起来的时候东找西找相关的状态和操作。</p>
<p>不过，Vuex的modules不就可以解决了吗？不过缺点可能就是颗粒度大了一点.</p>
<p>用新API尝试取代Vuex我认为数据量少时可以使用，多起来了，还是Vuex这样的中心管理较好。</p>
<p>当然，利用provide/inject 实现useContext和useReducer的效果我认为也是不错的。</p>
<p>嗨说到这里就想挖vuex和vue-router的源码了。另开文章吧~</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

