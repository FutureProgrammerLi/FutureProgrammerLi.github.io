<!DOCTYPE html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="学习日记11-26"><meta name="author" content="Future Li"><meta name="keywords" content="日记"><meta name="copyright" content="copyright.liscense_type"><title>学习日记11-26</title><!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]><script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script><script src="https://cdn.bootcss.com/respond/1.4.2/respond.min.js"></script><![endif]--><link rel="icon" href="/compass/imgs/favicon.ico"><link rel="stylesheet" href="/compass/stylesheets/font-awesome.min.css"><script>var algoliaConfig = {"on":false}</script><link rel="stylesheet" href="/compass/stylesheets/screen.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div id="body-inner-wrapper"><header id="page-header"><nav id="nav"><div id="site-name">CodingLiveLi</div><i class="fa fa-bars fa-2x" id="nav-icon" aria-hidden="true"></i><div id="nav-expanded"><a class="nav-word-item" href="/">Home</a><a class="nav-word-item" href="/archives">Archives</a></div><div id="nav-list"><ul><li><a class="nav-list-item" href="/">Home</a></li><li><a class="nav-list-item" href="/archives">Archives</a></li></ul></div></nav><div id="banner-wrapper"><div id="banner-pagetype-dependent-info"><h1 id="post-title">学习日记11-26</h1><span id="post-description"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-11-26</span><span id="word-count">The total word count - 1486</span><span id="time-count">Estimated time of reading - 5 mins</span></div></div><a title="Back to Top"><i class="fa fa-arrow-up" id="to-Top" aria-hidden="true"></i></a><a title="Click to Toggle off"><i class="fa fa-toggle-on" id="toggle-on-Toc" aria-hidden="true"></i></a><a title="Click to Toggle on"><i class="fa fa-toggle-off" id="toggle-off-Toc" aria-hidden="true"></i></a></header><aside id="toc-column"><div id="toc-column-inner-wrapper"><div id="post-toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">Vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">心得：</span></a></li></ol></div></div></aside><main id="main-content-column"><div id="main-content-wrapper"><div id="post-full-content"><h2><span id="引言">引言</span></h2><p>  最近发现光看视频，不仅看完觉得自己会了，上手就不会，而且还会很容易困…没错，说的就是functional-light…英语视频一旦没跟上就感觉睡着了一样，就看不懂了。嗨，还有20多P..</p>
<p>  还是边学边码一些感想和学习内容感觉更容易记下来，虽然也不知道自己会不会重新翻看，但起码有了可以复习的内容，不像看视频那样：哦<del>我懂了。两天后，我懂啥了？哦哦哦，就那个，啥？想复习都没根据了。（额，说话全是普通话了。Whatever</del>）</p>
<p>  就记录一下吧，不知道可以持续多久，但~起码维持到找到工作之后吧。</p>
<h2><span id="vue">Vue</span></h2><blockquote>
<p>有了composition API提供的一些函数，是不是就不用vuex了呢？</p>
</blockquote>
<p>先看一个，用provide/inject实现的，类vuex的功能。</p>
<p>问题：</p>
<ol>
<li>vue2也有provide和inject，为什么必须用到了reactive,computed,readonly这些API才能把vuex的部分功能给模拟出来呢？</li>
<li>vuex的模块化怎么用这些API模拟出来？</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, readonly &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> stateSymbol = <span class="built_in">Symbol</span>(<span class="string">'state'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">        counter: <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state.counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        state:readonly(state),</span><br><span class="line">        increment</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useState = inject(stateSymbol);</span><br><span class="line"><span class="comment">//./store/index.js</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore, stateSymbol &#125; <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line">app.provide(stateSymbol,createStore());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>直接在app层provide整个store,整个应用都可以共享到这个state了。</p>
</li>
<li><p>stateSymbol意图不明显，为了确保唯一?如果要多个仓库的话如何实现呢？</p>
</li>
<li><p>在createStore里面</p>
<ul>
<li>方法里面，reactive是可以被改变的，只不过在导出的时候才用readonly再次包装。</li>
<li>导出时用readonly，保证了只允许createStore里的方法可以修改这个state，而不是被乱改。</li>
<li>除了reactive和function,还可以用computed模拟vuex的getters,用function/ async function模拟mutations/actions.（还强制actions里调用mutations里的方法吗？没了吧？）</li>
</ul>
</li>
</ul>
<p><strong>重大问题，被包裹了两层。在组件里访问counter,要用state.state.counter,state.increment.</strong> </p>
<p>createStore里包裹成了对象，组件里又被包裹成了对象.</p>
<blockquote>
<p><a href="https://medium.com/better-programming/why-you-might-not-need-vuex-with-vue-3-61ad09e62334" target="_blank" rel="noopener">https://medium.com/better-programming/why-you-might-not-need-vuex-with-vue-3-61ad09e62334</a></p>
<p>原文链接</p>
</blockquote>
<p>其它文章大同小异，主要的API还是provide和inject.</p>
<p>Vuex是否就可以抛弃了呢?并不，它有以下优点:</p>
<ol>
<li>易于调试, mutations are trackable, and time-travel ability is allowed by Dev tools.</li>
<li>插件多. vue-persisted / Vue Router,…etc.不少功能Composition API也能模拟，但没有Vuex这样结构化标准化。</li>
</ol>
<hr>
<blockquote>
<p><a href="https://vueschool.io/articles/vuejs-tutorials/state-management-with-composition-api/" target="_blank" rel="noopener">https://vueschool.io/articles/vuejs-tutorials/state-management-with-composition-api/</a></p>
<p>原文链接</p>
</blockquote>
<p>用ref和computed两个API写一个vuex.</p>
<p>一个亮点是，可以用watch或watchEffect,用数组模拟实现vuex的调试/time travel功能。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> histroy = [];</span><br><span class="line">watch(state,(newState,oldState)=&gt;&#123;</span><br><span class="line">    history.push(oldState);</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>还有一个，允许自己写的Composition 分享状态而不是每个函数作用域每一次全新的状态。（提升到文件全局就行）</p>
<p>封装一个vuex获取数据的hooks：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed, readonly &#125; <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">useProduct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> loading = ref(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">const</span> products = ref([]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">search</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">        loading.value = <span class="literal">true</span>;</span><br><span class="line">        products.value = <span class="keyword">await</span> fetchProducts(params);</span><br><span class="line">        loading.value = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">		loading: computed(<span class="function"><span class="params">()</span> =&gt;</span> loading.value),</span><br><span class="line">        products:computed(<span class="function"><span class="params">()</span> =&gt;</span> products.value),</span><br><span class="line">        search</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//function search(params:Object)=&gt;void</span></span><br></pre></td></tr></table></figure>

<p>computed可以用readonly代替，只是为了不让函数外部的代码修改这里的值.(computed返回的值是不可修改的)</p>
<p>个人认为存在不足:导出的search是否有类型推断？是否需要查看整个hook才能知道它是函数，才能知道它接收的参数是什么？</p>
<p>好处是不会像Vuex那样，没有数据也用空数组或对象先声明出来，而是需要的时候才会创建相应的数据，比如这里的products.</p>
<p>而且这样用，products是互相独立的，每一次的函数调用都会有不同的products(?).</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useProduct &#125; <span class="keyword">from</span> <span class="string">'./hooks'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    setup(props,ctx)&#123;</span><br><span class="line">        <span class="keyword">const</span> id = ctx.root.$route.params.id;</span><br><span class="line">        <span class="keyword">const</span> &#123; products, loading, search &#125; = useProduct();</span><br><span class="line">        <span class="keyword">await</span> search(id);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            product: computed(<span class="function"><span class="params">()</span> =&gt;</span> products.value[<span class="number">0</span>]),</span><br><span class="line">            loading</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compositions之间共享数据的两种方法:</p>
<ol>
<li><p>偏向vuex的模式，向外暴露修改状态的方法，通过引入函数的方式在各个compositions里使用。问题是依赖了外部的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = ref(&#123;</span><br><span class="line">    cart:[]</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> setCart = <span class="function">(<span class="params">cart</span>) =&gt;</span> &#123; state.value.cart = cart &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; setCart &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//各个hooks内:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCart</span>(<span class="params"></span>)</span>&#123; setCart(&#123; data &#125;); &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">anotherCart</span>(<span class="params"></span>)</span>&#123; setCart(&#123; data &#125;); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更好的方法，直接将需要共享的状态提升到外部.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cart = ref(&#123;&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCart</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        cart:computed(<span class="function"><span class="params">()</span> =&gt;</span> cart.value;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2><span id="心得">心得：</span></h2><p>Vuex这种中心状态管理模式真能被取代吗？</p>
<p>如果用函数，向外暴露的方法，状态和方法少的情况下可以优化，但多起来，尤其是Composition API,return出来的东西不就更多了？</p>
<p>而直接显式的表明mutations,actions,我认为并不比vue3的function/async function差。能想到的好处大概是可以把相关的逻辑放在相同的位置，就是原本Composition替代Options那样的思想，不用多起来的时候东找西找相关的状态和操作。</p>
<p>不过，Vuex的modules不就可以解决了吗？不过缺点可能就是颗粒度大了一点.</p>
<p>用新API尝试取代Vuex我认为数据量少时可以使用，多起来了，还是Vuex这样的中心管理较好。</p>
<p>当然，利用provide/inject 实现useContext和useReducer的效果我认为也是不错的。</p>
<p>嗨说到这里就想挖vuex和vue-router的源码了。另开文章吧~</p>
</div><div id="post-tags-container"><i class="fa fa-tags"></i> <a class="post-tag" href="/tags/%E6%97%A5%E8%AE%B0/">#日记</a></div><div id="post-categories-container"><i class="fa fa-folder-open"></i>
 <a href="/categories/Javascript/">Javascript</a> / <a href="/categories/Javascript/Vue/">Vue</a></div></div></main><div id="pagination-wrapper"><a id="page-prev" href="/2020/11/30/Vuex/"><i class="fa fa-chevron-left"></i> Vuex</a><a id="page-next" href="/2020/11/24/11-23%E9%9D%A2%E8%AF%95/">11-23面试 <i class="fa fa-chevron-right"></i></a></div><footer id="page-footer"><div id="footer-wrapper"><div id="blog-meta">&copy;2017-2021 By Future Li | Theme - <a id='theme-name' href="https://github.com/huan555/lemon-lime" target="_blank" rel="noopener"> Lemon-Lime</a> | Power By <a id='theme-powered-by' href=http://hexo.io> Hexo</a></div><div id="viewed-record"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span></span></div><div id="copyright-wrapper"><i class="fa fa-cc" aria-hidden="true"></i><div id="copyright">Except where otherwise noted, content on this blog is licensed under <a rel="license" href=http://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a>.</div></div><div id="contact-me"><div id="rss"><a href="/atom.xml" type="application/atom+xml" rel="alternate" target="_blank"><i class="fa fa-rss" aria-hidden="true"></i></a></div><span id="github"><a href="https://github.com/FutureProgrammerLi" target="_blank" rel="noopener"><i class="fa fa-github" aria-hidden="true"></i></a></span><span id="weibo"><a href="https://weibo.com/1903816767/profile?rightmod=1&amp;wvr=6&amp;mod=personnumber" target="_blank" rel="noopener"><i class="fa fa-weibo" aria-hidden="true"></i></a></span></div></div></footer><script src="/compass/js/blog.js"></script></div></body>