<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Future Li">
  <!-- Open Graph Data -->
  <meta property="og:title" content="函数式编程"/>
  <meta property="og:description" content="Hello World!" />
  <meta property="og:site_name" content="CodingLiveLi"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="CodingLiveLi" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>CodingLiveLi</title>

  <!-- Bootstrap CSS -->
  
<link rel="stylesheet" href="/css/bootstrap.min.css">

  <!-- Custom CSS -->
  
  
<link rel="stylesheet" href="/css/style.light.css">


  <!-- Google Analytics -->
  

<meta name="generator" content="Hexo 4.2.1"></head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">函数式编程</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/FutureProgrammerLi" target="_blank" rel="noopener">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:617612567@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Future Li</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2020-11-17</span>
            <span class="time">22:05:52</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/Javascript/">Javascript</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/Javascript/">#Javascript</a> <a class="tag" href="/tags/%E5%87%BD%E6%95%B0/">#函数</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1><span id="对函数的一些思考"> 对函数的一些思考</span></h1>
<p>函数式编程可以说是很有用，增强编码可读性、可维护性的一大利器了。我觉得是一种类似面向对象编程这样，一个大类的编程风格。给我的感觉是，虽然编写时可能会复杂了些，但在日后的维护、复用、扩展等等的方面都大有用处。</p>
<p>之前看的Functional-Light-Javascript, 看了一半没看下去了，在通勤时看，感觉没有入脑。读完/重读我感觉也是不久后的事了。而且，我认为现在的Vue的composition API，React的hooks，都是基于函数的，而且高阶函数、闭包、修饰器模式，甚至后端的中间件等都是函数。显然，熟悉函数对学习JS是必然的事了。</p>
<p>所以接下来的目标是，先看完设计模式，之后就着重再看一遍Functional-Light-Javascript吧，感觉它跟You Dont Know JS Yet 一样，都是些深入JS的东西。</p>
<p>以下是掘金看到的，函数的一些应用，包括柯里化，组合函数，缓存函数，惰性函数这些。</p>
<blockquote>
<p>原文地址：<a href="https://juejin.im/post/6892886272377880583" target="_blank" rel="noopener">https://juejin.im/post/6892886272377880583</a></p>
<p>作者：阿宝哥</p>
<p>(感谢)</p>
</blockquote>
<h2><span id="1高阶函数"> 1.高阶函数，</span></h2>
<ol>
<li>将函数作为参数的函数； 比如数组的map,filter,reduce,sort.(所以回调也是咯?addEventListener?)</li>
<li>函数的返回是一个函数。柯里化、闭包、bind，debounce、throttle.(个人认为bind最好理解，对比call和apply)</li>
</ol>
<p>我认为好理解的还有redux，context，将需要的一些状态利用函数的方式提供给/包裹相应组件。</p>
<h2><span id="2函数组合"> 2.函数组合</span></h2>
<p>将多个函数，按照一定的顺序执行下去。第一个函数的执行结果/返回值是第二个函数的输入。类似于管道,Linux的管道操作符，Vue模板里的filter。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">arg,fn</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn(arg);</span><br><span class="line">        &#125;,x);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//返回的是个函数，执行这个返回值之后才实际调用reduce方法顺序执行传进来的函数</span></span><br></pre></td></tr></table></figure>
<p>如果想逆序执行，用reduceRight。如果想任意顺序，建议柯里化。（应该可以吧）</p>
<p>以下是node的中间件实现函数，没看懂，希望回头来看可以懂一点点吧。码了再说。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">context,next</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=index)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>));</span><br><span class="line">            &#125;;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">            <span class="keyword">if</span>(i === middleware.length) fn = next;</span><br><span class="line">            <span class="keyword">if</span>(!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context,dispatch(<span class="literal">null</span>,i+<span class="number">1</span>)));</span><br><span class="line">            &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类似axios里的request.interceptor和response.interceptor</span></span><br></pre></td></tr></table></figure>
<h2><span id="3柯里化"> 3.柯里化</span></h2>
<p>个人理解，一个函数要接收多个参数，而你由于其它限制，不能一次把这些参数全部传进去。而柯里化就是为了保留你之前传进去的参数而生成新的函数，而这些函数相当于原本函数的，预先输入好参数了的新函数，你只需要把剩下的参数继续传进这些新参数直到符合要求，就能实现原先函数的功能。</p>
<p>我可以理解的例子是，构建URL：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUri</span>(<span class="params">scheme, domain, path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;scheme&#125;</span>://<span class="subst">$&#123;domain&#125;</span>/<span class="subst">$&#123;path&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> profilePath = buildUri(<span class="string">"https"</span>, <span class="string">"github.com"</span>, <span class="string">"semlinker/semlinker"</span>);</span><br><span class="line"><span class="keyword">const</span> awesomeTsPath = buildUri(<span class="string">"https"</span>, <span class="string">"github.com"</span>, <span class="string">"semlinker/awesome-typescript"</span>);</span><br></pre></td></tr></table></figure>
<p>前两个参数显然可以复用，只有第三个是变化的，但是又不能只局限于github这个网站的URL.</p>
<p>所以你可以生成一个新函数，预设的参数是github的，这样就不妨碍其它主机名的网站了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'loadash'</span>);</span><br><span class="line"><span class="keyword">const</span> buildUriCurry = _.curry(buildUri);</span><br><span class="line"><span class="keyword">const</span> githubPath = buildUriCurry(<span class="string">'https'</span>,<span class="string">'github.com'</span>);</span><br></pre></td></tr></table></figure>
<p>之后你就有一个专门访问github的函数了，只需要传path这个参数就行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> profilePath = githubPath(<span class="string">'semlinker/semlinker'</span>);</span><br><span class="line"><span class="keyword">const</span> awesomeTsPath = githubPath(<span class="string">"semlinker/awesome-typescript"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>所以，柯里化的一个作用是，保留参数，直到符合形参个数才执行函数功能。</strong></p>
<h3><span id="柯里化的实现"> 柯里化的实现</span></h3>
<p>思路是判断传进来的函数形参要求和实际传进来的实参个数是否相等，如果相等则直接执行，否则将当前函数保存起来，返回另一个函数，直到传进来的实参和要求的形参个数相等，利用concat保留之前的实参。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(args.length &gt;= fn.length)&#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>,args);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>,args.concat(args2));</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//ES6, sundial_dreams, 也挺好理解的 //</span></span><br><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn,args=[]</span>) =&gt;</span>&#123;</span><br><span class="line">    args.length === fn.length? fn(...args) : <span class="function">(<span class="params">...args1</span>) =&gt;</span> curry(fn,[...args,...args1])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="4偏函数"> 4.偏函数</span></h2>
<p>我觉得，偏函数就是bind.</p>
<blockquote>
<p>Partial application refers to the process of fixing a number of arguements to a function, <em>producing another function of smaller arity.</em></p>
<p>Currying is the technique of translating the evaluation of a function that takes multiple arguments into evaluating <em>a sequence of functions</em>, each with a single argument.</p>
</blockquote>
<p>柯里化偏向函数执行顺序？偏函数偏向参数保留？柯里化n元化成n * 1 元， 偏函数n元化成 n - x元？</p>
<p>对比一下，currying是链式的，而partial是直接生成新函数的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> buildUriCurry = _.curry(buildUri);</span><br><span class="line"><span class="keyword">const</span> usingCurry = buildUriCurry(<span class="string">'https'</span>,<span class="string">'github.com'</span>);</span><br><span class="line"><span class="keyword">const</span> usingPartial = _.partial(buildUri,<span class="string">'https'</span>,<span class="string">'github.com'</span>);</span><br><span class="line"><span class="comment">//const usingCurry = [_.curry(buildUri)]('https','github.com'); //为了理解</span></span><br></pre></td></tr></table></figure>
<h3><span id="偏函数的实现"> 偏函数的实现</span></h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>);     <span class="comment">//类数组变数组，并保存起来，为什么是1?</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> newArgs = args.concat([].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,newArgs);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="5惰性函数"> 5.惰性函数</span></h2>
<p>我觉得作者举的例子更像能力检测，是根据浏览器的差异，使用不同的方式为元素添加事件。众所周知，老IE不支持addEventListener。而如果只用单纯的if判断，那么每次使用都会进行大量的无用判断。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addHandler = (ele,type,handler)&#123;</span><br><span class="line">    <span class="keyword">if</span>(addEventListener)&#123;</span><br><span class="line">        ele.addEventListener(type,handler,<span class="literal">false</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(attachEvent) &#123;</span><br><span class="line">        ele.attachEvent(<span class="string">"on"</span> + type,handler);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ele[on+<span class="string">"type"</span>] = handler;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而使用惰性函数，<strong>能力检测，那么直接将该函数覆盖就行</strong>，毕竟能就是能，不能就是不能，你多次判断结果也是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addHandler = (ele,type,handler)&#123;</span><br><span class="line">    <span class="keyword">if</span>(addEventListener)&#123;</span><br><span class="line">        addHandler = <span class="function">(<span class="params">ele,type,handler</span>) =&gt;</span>&#123;</span><br><span class="line">            ele.addEventListener(type,handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(attachEvent) &#123;</span><br><span class="line">        addHandler = <span class="function">(<span class="params">ele,type,handler</span>) =&gt;</span>&#123;</span><br><span class="line">            ele.attachEvent(type,handler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        addHandler = <span class="function">(<span class="params">ele,type,handler</span>) =&gt;</span>&#123;</span><br><span class="line">            ele[on+<span class="string">"type"</span>] = handler;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> addHandler(ele,type,handler);</span><br><span class="line">    <span class="comment">//保证第一次执行成功，或者用立即执行函数代替</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2><span id="6缓存函数"> 6.缓存函数</span></h2>
<p>应用好像很广，在Vue的keep-alive和设计模式里面见过。</p>
<p>利用闭包将之前传过进来的参数，以及得出的结果保存起来，下次传相同的参数的话直接从这个对象获取，就不用重新计算了。尤其是Fibonacci数列，每一个结果都依赖前两项的结果，用处就更明显了。</p>
<p>思路也比较简单，主要是保存，在下次调用时检查缓存对象中是否有对应参数的，有就直接返回结果，没有就重新计算。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> _args = <span class="built_in">JSON</span>.stringify(args);</span><br><span class="line">        <span class="keyword">return</span> cache[_args] || (cache[_args] = fn.apply(fn,args));</span><br><span class="line">        <span class="comment">//重点</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>缓存数量应该要有限制，否则遍历结果对象比计算新结果的成本还大的话，缓存来做什么？</p>
<hr>
<h2><span id="总结"> 总结</span></h2>
<p>回头看看，主要记到的有</p>
<ol>
<li>
<p>高阶函数(filter/map , bind/debounce)</p>
</li>
<li>
<p>函数组合(管道)</p>
</li>
<li>
<p>柯里化/偏函数(函数顺序化,参数保留)</p>
</li>
<li>
<p>能力检测(用函数覆盖的形式,取代每次都要验证)</p>
</li>
<li>
<p>缓存函数(用闭包保存之前的计算结果,之后传同样参数进来时,直接返回相应的属性值.)</p>
</li>
</ol>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->

<script src="/js/highlight.pack.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

