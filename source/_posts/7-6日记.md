---
title: 7-6日记
date: 2020-07-07 00:34:09
tags: 
- JavaScript
- Vue
excerpt: reduce的一些用法/ Vue-router 4 的API / 算法题*2
---

# 1. reduce的一些用法

> Array.prototype.reduce((acc,cur,index,array)=>{}, base)
>
> acc累加器 / cur 正在执行的值 / index 正在执行的值在数组中的索引 / array 整个数组
>
> base, 基值, 亦为initialValue
>
> 提供base, 则第一次执行时,acc则为base, cur则为数组第一个值(索引为0)
>
> 不提供base, 则第一次执行数组下标0的值作为acc, 下标1的值为cur
>
> 数组为空,且base也不提供,则TyepError
>
> 数组只有一个元素, 或者数组为空,只提供base,则不执行callback, 直接返回那个值.
>
> Always provide the base/ initial value for safety purpose.

(摘自MDN)

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce

## Examples

### 1.sumAll(求和)

```js
let sum = [1,2,3,4,5].reduce((acc,cur)=>acc+cur,0)     //15
```

### 2. sum of values in object array(对对象数组的某个属性值求和)

```js
let objArr = [
    {x:0},
    {x:2},
    {x:3}
]
let sum = objArr.reduce(function (acc,cur){
   acc + cur.x           //注意这里是acc,不是acc.x,因为acc一开始就是0
},0)
```

### 3.Flatten an array (二维数组转为一维)

```js
let flattened = [[0,1],[2,3],[4,5]].reduce((acc,cur)=>{
    return acc.concat(cur)
},[])       //利用了concat, 当前只能将二维数组转为一维
```

### 4.Counting times of a value in an object/array(统计元素/属性在数组/对象中出现的次数)

```js
let arr = [1,2,3,4,5,6,7,1,1,2,3,4,5,1,2,3,2,3,1,2]
let result = arr.reduce((acc,cur)=>{
    if(cur in acc){
        acc[cur]++
    }else{
        acc[cur] = 1
    }
    return acc
},{})   //是对象不是数组, 元素本身作为属性名,出现次数作为值
```

### 5.Grouping objects by a property(根据某一属性值分类对象)

```js
let people = [
  { name: 'Alice', age: 21 },
  { name: 'Max', age: 20 },
  { name: 'Jane', age: 20 }
];
function groupBy(objectArr,property){
    return objectArr.reduce((acc,obj)=>{
        let key = obj[property];  //属性值
        if(!acc[key]){
            acc[key] = []        //20:[], 21:[]
        }
        acc[key].push(obj)       
        return acc
    },{})
}
console.log(groupBy(people,'age'))
//{20:Array(2),21:Array(1)}
//思路,将需要分类的属性值(20,21)作为属性名,属性值是数组. 
//似乎跟累加无关? 更像遍历,acc只不过负责凑成整体
```

### 6.Put all array items of objects into one(将对象数组的某一属性添加到同一个数组中)

```js
let friends = [{
  name: 'Anna',
  books: ['Bible', 'Harry Potter']
}, {
  name: 'Bob',
  books: ['War and peace', 'Romeo and Juliet']
}, {
  name: 'Alice',
  books: ['The Lord of the Rings', 'The Shining']
}]
let allBooks = friends.reduce((acc,cur)=>{
    return [...acc,cur.books]       //第一次acc是['Alphabet'],cur是Anna这个对象
},['Alphabet'])
```

### 7. Remove duplicate keys in an array(数组去重)

```js
let arr = [1,2,3,4,5,1,2,3,1,2,1,2,1]
let result = arr.reduce((acc,cur)=>{
   if(acc.indexOf(cur) === -1){     //acc中不存在的元素才push到acc中。保证每次push都不是重复的
       acc.push(cur)
   }
    return acc
},[])
```

### 8. Replace .filter().map() with reduce() / 用reduce取代.filter().map()

```js
const nums = [-1,-2,1,2,3,4,5]
const doubledPositive = nums.reduce((acc,cur)=>{
   if(cur>0){          //filter
       cur*=2          //map
       acc.push(cur)
   } 
    return acc
},[])
//表明reduce和map一样，返回一个修改完之后的数组而不修改数组本身
```

### 9. Pipes/Running functions in sequent order.(管道执行函数/或promises)

```js
//Promises版本
function runPromiseInSequence(arr, input) {
  return arr.reduce(
    (promiseChain, currentFunction) => promiseChain.then(currentFunction),
    Promise.resolve(input)
  )
}  //input作为函数传入，类似arr.reduce(cbs,input)

function p1(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 5)
  })
}
function p2(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 2)
  })
}
// function 3  - will be wrapped in a resolved promise by .then().(why?)
// special case.
function f3(a) {
 return a * 3
}
function p4(a) {
  return new Promise((resolve, reject) => {
    resolve(a * 4)
  })
}

const promiseArr = [p1, p2, f3, p4]
runPromiseInSequence(promiseArr, 10)
  .then(console.log)   // 1200
```

```js
// Building-blocks to use for composition
const double = x => x + x
const triple = x => 3 * x
const quadruple = x => 4 * x

// Function composition enabling pipe functionality
const pipe = (...functions) => input => functions.reduce(
    (acc, fn) => fn(acc),
    input
)

// Composed functions for multiplication of specific values
// All are closures returned by pipie.
const multiply6 = pipe(double, triple)
const multiply9 = pipe(triple, triple)
const multiply16 = pipe(quadruple, quadruple)
const multiply24 = pipe(double, triple, quadruple)

// Usage
multiply6(6)   // 36, equals to pipe(double,triple)(6)
multiply9(9)   // 81
multiply16(16) // 256
multiply24(10) // 240
```

# 两道算法题

## 找出数组中第k大/小的元素

思路: 不可能遍历排序之后再找,效率极低.

1. 创建一个大小为k的数组result,遍历,
2. 一开始将原数组前k个元素全部push到新数组result中,

3. 指针寻找下一个,比较下一元素与数组中的所有值(?),找出最大或者最小的将其替代
4. 之后指针再指向下一个元素,重复第三步

如果要找第k大的,指针元素比result数组中的都大,则用指针元素替换result数组中最小的元素

(每次找出result数组中的最大或最小元素是否能避免,指针元素跟result数组每个元素比较这一步?)

---

## 计算路径(动态规划)

机器人在n*m矩阵行走,左上走到右下, 设置障碍,计算可行路径有多少条

没有障碍的情况下,当前所在位置相当于走到左边位置的路径数加上走到上边位置的路径数之和.

设置障碍,相当于走到当前位置的左侧或者上侧数字为0(走不到有障碍的路径)