---
title: 深入理解es6-8
date: 2019-12-29 19:07:24
tags: 
- Javascript
- 深入理解ES6
excerpt: 迭代器和生成器(Iterators & Generators)
categories: 
- 书本
---
### 深入理解es6第八章 迭代器和生成器
#### 1.迭代器:
`问题引入`:
```
let arr = ["red","green","yellow"]
for(var i =0,len = arr.length;i<length;i++){
    console.log(arr[i])          //循环数组的传统做法
}
```
*需要追踪多个变量*
**迭代器旨在消除这种复杂性,减少循环中的错误**
##### 特点:
1. 有一个value,一个done,以及一个next()方法
2. 每次执行next()方法都会读一个值value,一个boolean值done.表示当前位置以及读完整个数组没有
3. 遍历完的特征是done:true, (value是函数调用过程中最后一次给调用者传递信息的方法?
  *三个元素的数组执行4次next(),  第三次done为false, 第四次value为undefined,done为true*
用ES5语法编写一个迭代器:
```
function createIterator(items){
    var i = 0;
    return{
        next: function(){        //es5语法,所以不能简写为next(){}
        var done = (i>=items.length?)
        var value = !done?items[i++]:undefined;
        return {
            done:done,            //同样是因为es5语法所以还是要写两个
            value:value           //返回的是一个对象
        }
        }
    }
}
```

---
#### 2.生成器:返回迭代器的函数(就是上面那段东西)
1. 创建:*与普通函数不同的只是星号
```
function *createIterator(){
    yield 1;
    yield 2;                 
    yield 3;
}
//或者
let iter = function *(items){

}
var iterator = createIterator();     //还是像正常函数一样执行
```
**yield语法相当于往里面塞东西,类比数组的push方法**
**yield只能在生成器内部使用,生成器里面再有函数,在该函数内也是用不了yield的**
上面的就像一个`断续创建`的数组[1,2,3],而且自己可以遍历
断续创建是因为`每次执行一条yield语句函数就不再执行其它任何语句`
```
function *createIterator(){
				 yield 1;       //[1]
				 console.log('哈哈');
				 yield 2;         //[1,2]
			 }
			 var iter = createIterator();
			 console.log(iter.next());
			 console.log(iter.next()); //哈哈和一个Object{value:2,done:false}
```

将数组变成迭代器(?):
```
function *createIterator(items){
    for (let i = 0 ; i<items.length;i++){
        yield items[i]
    }                                   //给数组添加遍历的方法,主要是利用yield可以间断执行吗?forEach不好吗?
}
let iterator = createIterator([1,2,3]);
console.log(iterator.next());    //{value:1,done:false}
```

##### 可迭代对象和for-of
所有的`集合对象`和`字符串`都是可迭代对象（数组,Map,Set)
用于可迭代对象的特殊循环, **只能用于可迭代对象**.
```
var nums = [1,2,3]
for (let num of nums){      //for-of语法
    console.log(num)
}
```
迭代器是可迭代对象里的一个对象还是方法?
```
var nums = [1,2,3]
var iter = nums[Symbol.iterator](); //执行对象里的方法?symbol属性怎么理解? 类比Array[push]?执行该方法返回的是一个迭代器?
console.log(iter.next())
```

```
nums = {
    Symbol.iterator: function(){
        // ....将数组看成对象,里面有一个属性,返回一个迭代器,可以调用next()方法
        return iterator
    }
}
```

检测是否为可迭代对象:检查Symbol.iterator是否是函数
```
function isIterable(obj){
    return typeof obj[Symbol.iterator] === 'function';
}
```

#### 内建迭代器
##### 集合对象的迭代器(数组,set,map) 都有三种
1. entries() 
2. values()
3. keys()
`entries`,都是返回数组:
**数组返回下标和对应值**
**Set返回的都是值**
**Map返回的是键名和值**
---
`values`,返回值
`keys`,返回键名
*访问方法*
```
var nums = [1,2,3]
for(let num of nums.entries()){ //num of nums.values()|| num of nums.keys()
    console.log(num)
}
```
`默认使用的迭代器: 数组和Set是 values(); Map是 entries()`
直接for (let item of nums)
--- 
#### 展开运算符和可迭代对象
典型形式
var newArray = [...set];
    newArray2 = [...map];
1. Set集合展开后用数组存储,变成*全是值的数组*(因为默认迭代器返回的就是值,迭代器和展开运算符的联系?(values()))
2. Map集合展开后用数组存储,变成*值是数组的数组*(数组里面套数组) (entries()返回的是键值对) [["name":"Nicholas"],["title":"ES6"]]
---
#### 高级迭代功能
1. 给next()传参:
**第一次执行next(),给它传参是无用的.**
每一条yield语句都会返回一个值,而给next()传参相当于修改对应yield语句返回的值
```
function *createIterator(){
    let first = yield 1;
    let second= yiled first+2;       //可以将yield类比成 return一个表达式吗?
    yield second+3;
}
let iterator = createIterator()
console.log(iterator.next());  //1
console.log(iterator.next(4));  //6
```
执行到yield程序就终止,等待下次next(),所以*赋值语句在第一次执行next()时不会执行?*
first其实等于4,而不等于1
用到yield语句的,可以利用next()和throw()方法控制执行过程.
---
2. 生成器里的return语句
遇见return整个函数就终止,可以指定return一个值,但只会在next()方法中出现一次,是done刚变回true的那一次next(),之后的value都会变undefined 
```
{value:42,done:true} //return 42;
```
*for-of循环不会打印return的值,done一变true就推出*
---
3.委托生成器
**重点:COMBINED**
整合,每次next()就按所在生成器内执行yield.
==>it1==>it1==>it1==>it2==>it2==>it2==>itCombined
```
function createCombinedIterator(){
    yield *createIterator1();
    yield *createIterator2();
    yield true;
}
```

```
function *createNumberIterator(){
    yield 1;
    yield 2;
    return 3;
}
function *createCombiendIterator(){
    let result = yield *createNumberIterator();     //result是生成器返回的值.如果不return是否就等于undefined了?
    //yield result;                                  //打印return的值
    yield *createRepeatIterator(result);
}
```
---
### 生成器的异步应用
```
function run(taskDef){
    let task = taskDef(); 
    //传入的是一个生成器的定义
    //类似就是 function *createIterator(){}
    //let iter = createIterator() 

    //开始执行第一个任务,返回一个对象{value: xxx, done:true/false}
    let result =task.next();

    function step(){
        if(!result.done){
            //检测yield后面是不是函数,是就去执行函数
            if(typeof result.value === "function"){
                result.value(function (err,data){
                    if(err){
                        result = task.throw(err)
                        return
                    }
            //将函数的执行结果传递给下一个任务
                    result = task.next(data)
                    step()
                })
            }else{
                //不是就直接下一个任务
                result = task.next(result.value)
                step()
            }
        }
    }
    //开始迭代执行
    step()
}
```
## 总结:
1. 判断是否为可迭代对象 (xxx[Symbol.iterator] === "function") true则是可迭代
2. for-of跟传统for相比,不用追踪值在集合中的位置,不需要控制循环结束的时机


