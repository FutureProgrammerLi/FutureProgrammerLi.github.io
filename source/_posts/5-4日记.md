---
title: 5-4日记
date: 2020-05-04 22:08:00
tags:
- Javascript
- 设计模式
categories:
- 整理
- Javascript
- 日记
excerpt: 发布订阅模式/装饰器适配器模式/代理模式/责任链模式
---

## 1.JS中的设计模式

##### 什么是设计模式？

套路。升级打怪的路线规划，避免浪费PL，利用最少的疲劳，最多的技巧，实现最快地升级。

`模式是一种可复用的解决方案，用于解决软件设计中遇到的常见问题`

100级刷什么图，做什么任务升级最快？有升级券吗？有经验胶囊吗？

**核心操作是：找出逻辑里的'变'与‘不变’，将它们分离。达到变的变灵活，不变的更稳定的目的。**

1. 策略模式

为了实现某个功能，供有多种方案可选择。--灵活运用不同的方法，将优秀的方法抽取并组合起来。

```js
//简单的多种判定
function check(data){
    if(data == 1){
        //..
    }
    if(data == 2){
        //..
    }
    if(data == 3){
        //..
    }
}
//问题=>策略项无法复用,违反开闭原则
```

使用策略模式改造代码:

```js
const jobList = ['FE','BE']
//策略
var stratigies = {
    checkRole: function(value){
        if(value === 'somerole'){
            return true
        }
        return false
    },
    checkGrade: function(value){
        if(value >=1){
            return true
        }
        return false
    },
    checkJob: function(value){
        if(jobList.indexOf(value)!=-1){
            return true
        }
        return false
    }
}

//验证
var Validator = function(){
    this.cache = []
    this.resultSet = []
    this.add = function(value,method){ //将策略放入数组中
        this.cache.push(function(){  //必须使用闭包吗?为了保护value和method吗?
            return stratigies[method](value);
        })
    },
    this.check = function(){
        for(let i =0;i<this.cache.length;i++){
            let validFn = this.cache[i]
            let res = validFn()
            //let res = this.cache[i]()
            this.resultSet.push(res)
        }
        return this.resultSet
    }
}
//使用
var example1 = function(){
    let validator = new Validator()
    const data = {
        role:somerole,
        grade:0,
        job:FE
    }
    validator.add(data.role,'checkRole')
    validator.add(data.grad,'checkGrade')
    validator.add(data.job,'checkJob')
    const result = validator.check()
    return result
}
example1()

```

* 适用场景

1. 判断逻辑互相独立且可复用
2. 判断逻辑相对复杂
3. 策略需要灵活组合

将判断整合成类而不是每次判断的时候都重新写?

为什么不直接将需要*多个判断*的逻辑整合成一个函数而是将多个不同逻辑的判断整合成一个类?

----

## 2.发布/订阅模式

一个事件完成后,需要通知其它事件更新相关数据.

例子:                      消息中心

申请成功 ===>     订单

​                              审核员

```js
//没有使用模式的写法
function success(){
    MessageCenter.fetch();
    Order.update();
    Check.alert();
}
//情况:1.某个方法名被修改,则该函数也要改
//    2.要添加新的通知事件就要修改函数
//    3.任一函数/模块未完成,该功能都无法实现
```

**发布/订阅模式**

​                                                     消息中心

申请成功 ==>  EventEmit  ==>  订单

​                                                      审核员

`不将消息直接发送给订阅者,而由EventEmitter统一广播出去,订阅者通过订阅获取想要的信息`

过去: '申请: "我搞定啦!你们什么时候才搞定阿?你们不搞定我也算没搞定的阿!"'

​          订单(没完成的功能):" 快了快了!" (刚开始)

发布订阅: 申请:"我搞定啦! 你们搞定了自己去EventEmitter里拿吧!"

​                  消息中心,审核员(已完成功能):"好的,这就去!" (subscribe)

​                 订单(未完成):"这么快的吗!?"          ……(若干小时后)"我搞定啦!!! 人呢??!"(默默subscribe)

```js
const EventEmit = function(){
    this.events = {}
    this.on = function(name,cb){
        if(this.events[name]){
            this.events[name].push(cb)       //为什么能用push?
        }else{
            this.events[name] = [cb]   //函数作数组项?
        }
    };
    this.trgger = function(name,...arg){
        if(this.events[name]){
            this.events[name].forEach(eventListener=>{
                eventListener(...arg) //遍历执行函数
            })
        }
    }
}
//使用
let event = new EventEmit();

MessageCenter.fetch(){
    event.on('success',()=>{
        console.log('通知消息中心')
    })
}
Order.update(){
    event.on('success',()=>{
        console.log('更新订单信息')
    })
}
//? 被通知的函数需要先运行一次,订阅对应事件,之后每次trigger就能触发?
event.trigger('success')
event.trigger('success')
event.trigger('success')    //每个订阅者都输出三次
```

* on是订阅,订阅的事件名是自定义的,可以是一系列函数

  第一次的events:       events['success'] = [cb1]

  第二次: events['success'] = [cb1,cb2]      ==>success就是统一的地方(集合区),cb就是各自的方法.

* trigger是通知.遍历执行函数.(用for循环是不是好点?)

  一次只能trigger一个数组内的函数?不能既触发success数组的函数,又触发fail(另一事件)数组的函数?

* 适用场景:
  1. 各模块相互独立
  2. 存在一对多的依赖
  3. 依赖模块不稳定、依赖关系不稳定(依赖的经常崩,或者有时依赖有时又不依赖那个"一"的模块)

## 3.装饰器模式/适配器模式

装饰器模式: 在原有功能上进行加工,功能变得更完善,更"好看".  //直接继承不香吗?

适配器模式: VGA转HDMI, USB转TYPE-C, 二插转三插(继承方法实现)

```js
//Decorator
const ori = function(){
    this.read = function(){
        console.log('我只看得懂中文')
    }
}
const Decorator = function(ori){
    this.read= ori.read;
    this.readEnglish = function(){
        console.log('我还懂英文')
    }
}
const old = ori()
const newObj = new Decorator(old)
newObj.readEnglish()
```

### 4.代理模式

VPN,黄牛,(保姆?),中间人,助手,Proxy.

由proxy代理操作对象本体,脏活累活交给助理(?),不用对对象本身操作

```js
//例子一,拦截某些来源的邮件
const emailList = ['qq.com','163.com','gmail.com']
const SendEmail = function(email){
    //发送邮件
}
const ProxyEmail = function(email){
    if(emailList.includes(email)){   //要截取email吧?
        //屏蔽
    }else{
        SendEmail.call(this,email)
    }   
}
ProxyEmail('abcd.com')
ProxyEmail('qq.com')
```

```js
//例子二,动态设置img的src
var domImage = (function(){
    var imgEle = document.createElement('img');
    document.body.append(imgEle);
    return{
        setSrc: function(src){
            imgEle.src= src
        };
    };
})()
var ProxyImg = (function(){
    var img = new Image();
    img.onload = function(){
        domImage.setSrc(this.src)
    };
    return{
        setSrc: function(src){
            domImage.setSrc('./loading.gif')      //预设置img为加载的gif图
            img.src= src
        };
    };
})()
ProxyImg.setSrc('./product.png')
```

## 5.责任链模式

**“避免请求发送者与接收者耦合在一起，让多个对象都有可能接受请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止”**

```js
//不运用模式的写法
function step1(){
    //...一段逻辑
    step2()
}
function step2(){
    //...
    step3()
}
function step3(){
    //...
    //More steps...
}
//弊端:如果需要插入步骤，则逻辑修改麻烦
```

```js
//运用责任链模式的写法
//仅为思路,以下代码实际好像不能运行(?)
const Chain = function(fn){
    this.fn = fn;
    this.setNext = function(){}
    this.run = function(){}
}
const f1 = function(){}
const ChainF1 = new Chain(f1)

const f2 = function(){}
const ChainF2 = new Chain(f2)

const f3 = function(){}
const ChainF3 = new Chain(f3)

ChainF1.setNext(ChainF2).setNext(ChainF3);
ChainF1.run()
```

* 思路1: this.fn = fn ==>设置起点, 每一个实例自身都可以当作责任链的开头
* ​        2: this.setNext = function(){}     设置链的下家,同样需要实例
* ​        3: this.run = function(){}            启动责任链
* 思路2:  每个节点都有自己的名字,调用handle时传入名字,如果名字相同,则责任链执行完成.如果next非空,则传给next的handler.

```js
//思路2的实现
class Handler {
  constructor() {
    this.next = null;
  }
  setNext(handler) {
    this.next = handler;      //关键点
  }
}

class LogHandler extends Handler {
  constructor(...props) {
    super(...props);
    this.name = "log";
  }
  handle(level, msg) {
    if (level === this.name) {
      console.log(`LOG: ${msg}`);
      return;
    }
    this.next && this.next.handle(...arguments);
  }
}

class WarnHandler extends Handler {
  constructor(...props) {
    super(...props);
    this.name = "warn";
  }
  handle(level, msg) {
    if (level === this.name) {
      console.log(`WARN: ${msg}`);
      return;
    }
    this.next && this.next.handle(...arguments);
  }
}

class ErrorHandler extends Handler {
  constructor(...props) {
    super(...props);
    this.name = "error";
  }
  handle(level, msg) {
    if (level === this.name) {
      console.log(`ERROR: ${msg}`);
      return;
    }
    this.next && this.next.handle(...arguments);
  }
}
let logHandler = new LogHandler();
let warnHandler = new WarnHandler();
let errorHandler = new ErrorHandler();
// 设置下一个处理的节点
logHandler.setNext(warnHandler);      //是否可以改为链式?
warnHandler.setNext(errorHandler);
logHandler.handle("error", "Some error occur");
```



文章内容:https://juejin.im/post/5e0eaff4e51d45413b7b77f3

本文为个人理解+文章摘抄.