---
title: 源码总结
date: 2020-05-08 22:41:14
tags:
- Javascript
categories:
- 整理
excerpt: create/new/bind/call/apply/Promise/防抖节流...
---

## 函数源码

### 1.create

思路:1.选择起点 2.认亲戚 3. 返回对象

```js
function _create1(instance){   
    let obj = {}      //1
    obj.__proto__ = instance //2
    return obj //3
}
function _create2(instance){
    function F(){};   //1
    F.prototype = instance  //2
    return new F()  //3
}
```



### 2.new

思路:1.创对象 2. 认亲戚 3.用父类构造函数加工 4.返回对象

```js
function _new(fn,...args){
   let obj = {}         //1
   obj.__proto__ = fn.prototype     //2令(3) =(6)
   fn.call(obj,...args)         //3
    return obj                  //4
}
```

### 3.call&apply

思路:传对象进来,不是对象就报错;

1.反身获取函数 2.给对象添加个函数 3.利用该对象执行函数 4.删除该函数 5.将执行的结果返回 

区别: 两个方法第一个参数都是对象,call第二个开始为参数,可有多个;apply第二个参数必须为数组,第三个参数或之后参数忽略

```js
function _call(context = window){
    context.fn = this             //1/2.获取函数
    //if主要判断第一个参数是否为对象. 后者判断更准确
    if(typeof arguments[0] == 'object' || Object.prototype.toString.call(arguments[0]) == '[object Object]'){
       let args = [...arguments].slice(1)    //处理传参.如果没穿,args直接为空
       let result = context.fn(...args)      //3.利用传进来的对象执行该函数
       delete obj.fn                     //4.删除
       return result                   //5.将结果返回
    }else{
        return NaN                    //错误处理
    }
}

function _apply(context = window){
    context.fn = this;         //1.2
    let result
    if(arguments[1] && Array.isArray(arguments[1])){
        result = context.fn(...arguments[1])      //3
    }else if (!arguments[1]){
        result = context.fn()  //需要吗?
    }else{
        return NaN
    }
    delete context.fn
    return result
}
```



### 4.bind

区别于call和apply: 返回一个可执行的函数; 可以连续传参: bind的时候传一次,返回值函数又传一次;返回值既可以new, 也可以直接函数式执行

思路:1.反身获取函数 2.保留一次传参 3.保留二次传参 4.判断new还是直接函数式执行返回的结果 5.返回实例

```js
function _bind(context = window){
    let fn = this                        //1
    let args1 = Array.prototype.slice.call(arguments,1)  //2
    return function F(){
        let args2 = Array.prototype.slice.call(arguments)     //3
        if(this instanceof F){                       //4
            return new fn(...args1.concat(args2))     //5.new执行返回结果
        }else{
            fn.apply(context,args1.concat(args2))      //5.函数式执行
        }
    }
}
//示例
Function.prototype._bind = _bind
function Person(name,age){
    this.name = name;
    this.age = age
}
let obj = { gender: 'male' }
let ret = Person._bind(obj,'zhangsan')
ret('22')          //给obj添加了zhangsan , 22两个属性值
let ret2 = new ret('23')       //obj本身的属性没了?! 原生的bind也没有gender
console.log(obj,ret2)
```

### 5.instanceof

思路:判断右侧的原型对象是否在左侧对象的原型链上.

```js
function _instanceof(instance,fn){ //instance是实例,fn是构造函数
    let leftProto = instance.__proto__
    let rightProto = fn.prototype
    if(leftProto === null){
        return false
    }
    if(leftProto === rightProto){
        return true
    }
    leftProto = leftProto.__proto__
    //注: 如果instance是fn的子类实例,则instance.__proto__.__proto__ = fn.prototype
    //为什么instance.__proto__不是一个fn的一个实例?
    //如果是子类,则instance.__proto__ = new fn()
}
```



### 6. Array.isArray&Array.of

isArray判断传入的是否为数组.

of方法参数当数组项,而不是数组长度.

new Array(3) 有两个意思:创建长度为3的空数组/创建第一个元素为3的数组

Array.of(3)     意思只有创建第一个元素为3的数组

```js
function _isArray(arr){
    return Object.prototype.toString.call(arr)      //polyfill
}
//Array.prototype._isArray = _isArray
let arr = [1,2,3]
_isArray[arr]         //true
//hack
Object.prototype[Symbol.toStringTag] = 'Whatever'
_isArray[arr]        //false
Array.isArray(arr)     //true 用的不是这个方法?!
```

```js
function _of(){
    let arr = []
    for(let i = 0;i<arguments.length;i++){
        arr.push(arguments[i])
    }
    return arr
    //return [].slice.call(arguments)      //类数组调用数组方法
    //return [].concat.call(arguments)
}
```

### 7.深浅拷贝

浅拷贝: 一指只复制对象的第一层,如果属性里还是对象则不复制

​            一指对象属性值是引用类型的,对拷贝出来的对象进行修改,被拷贝的对应属性值也被跟着修改

深拷贝:拷贝出来的跟本身的互不相关,且每一层的值都被复制.存储到完全两个不同的空间

```js
//举例深拷贝4种方法.浅拷贝4种
//深1 JSON 缺点:遇到undefined / 方法 / Symbol 无法拷贝
JSON.parse(JSON.stringify(obj))
//深2 递归  Iterable的属性好像都可以?
function deepClone(obj) {
    //重点1
        let objClone = Array.isArray(obj) ? [] : {};
        if (obj && typeof obj === "object") {
            for (key in obj) {   
                //key永远是属性名.是数组的话就是下标索引.obj是递归下去的项
                if (obj.hasOwnProperty(key)) {
                    if (obj[key] && typeof obj[key] === "object") {
                        //obj[key]永远是值.
                        //重点2
                        objClone[key] = deepClone(obj[key]);
                    } else {
                        objClone[key] = obj[key];
                    }
                }
            }
        }
        return objClone;
    }
//深3 利用jQuery库
$.extend(true,{},source)
//深4 利用loadash库
_.cloneDeep(source)      //没成功

//*************************************************************************************
//浅1
{...source}   // [...source]
[].slice(source)
[].concat(source)
//浅2
Object.assign({},source)
//浅3
let cloned = source
//浅4
function shallow(source){
    let result = Array.isArray?[]:{}
    for(i in source){
        result[i] = source[i]
    }
    return result
}
```



### 8.防抖&节流

思路:

防抖:利用定时器延迟执行,而不是每次触发都要有对应函数处理事件 //不再触发了才真正计时

节流:水滴式执行        //佛系执行,一段时间内执行次数可以说是固定的.

```js
function debounce(fn,time){
    let timer 
    return function(){
        let context = this
        let args = arguments
        if(timer){
            clearTimeout(timer)
        }
        timer = setTimeout(()=>{
            fn.call(context,args)
        },time)
    }
}

function throttle(fn,time){
    let pre = Date.now()
    return function(){
        let cur = Date.now()
        if(cur - pre >= time){
            fn.call(this,arguments)
            pre = cur
        }
    }
}

//测试 
body.onmouseover = debounce(()=>{
    console.log('debounce')
},1000)
body.onmouseover = throttle(()=>{
    console.log('throttle')
},1000)
```



### 9.Promise

基础:Promise有三种状态: pending / resolve / reject 

基本功能: 

1. 异步执行(promise里的函数未执行完,都不执行then/catch/finally)
2. 链式调用(then)
3. 错误捕捉(catch)
4. 最终执行(?finally)       (其它方法如all , race 等)

```js
const isFunction = val=>typeof val === 'function'
const PENDING ='PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class myPromise {
    //构造函数
    constructor(handle){
        if(!isFunction(handle)){
            throw new Error('Only accept a function as the param')
        }
        this._status = PENDING;
        this._value = undefined;
        this.fulfilledQueue = [];
        this.rejectedQueue = [];
        try{
            handle(this._resolve.bind(this),this._rejected.bind(this))
            //不解1:运行传进来的函数,以两个函数作为传进来的函数的参数?
            //为传进来的函数添加resolve和reject吗?不是吧?
        }catch(err){
            this._reject(err)
        }
    }
    
    //方法定义
    //resolve方法
    _resolve(val){
        //只有PENDING状态的才能执行这方法
        const run =()=>{
            if(this._status !== PENDING) return
            const runFulfilled = (value)=>{
                let cb;
                while(cb = this._fulfilledQueue.shift()){   //这能执行?
                    cb(value)
                }
            }
            const runRejected = (error)=>{
                let cb;
                while(cb = this._rejectedQueue.shift()){
                    cb(error)
                }
            }
            if(val instanceof MyPromise){  //判断是否为promise,是则递归,不是则直接当resolve?
                val.then(value=>{
                    this._value=value;
                    this._status = FULFILLED;
                    runFulfilled(value)
                },err=>{
                    this._value=err;
                    this._status = REJECTED;
                    runRejected(err)
                })
            }else{
                this._value = val;
                this._status = FULFILLED;
                runFulfilled(val)
            }
        }
        //为了支持同步Promise?
        setTimeout(run,0)
    }
    
   //reject方法
   _reject(err){
       if(this._status !== PENDING) return
       const run = ()=>{
           this._status = REJECTED;
           this.value = err;
           let cb;
           while(cb = this._rejectedQueue.shift()){
               cb(err)
           }
       }
       //同理,为支持同步Promise
       setTimeout(run,0)
   }
    
    //then方法
    then(onFulfilled,onRejected){
        const {_value, _status} = this
        return new myPromise((onFulfilledNext,onRejectedNext)=>{
            let fulfilled = value=>{
                try{
                    if(!isFunction(value)){
                        onFulfilledNext(value)
                    }else{
                        let res = onFulfilled(value);
                        if(res instanceof myPromise){
                            res.then(onFulfilledNext,onRejectedNext)
                        }else{
                            onFulfilledNext(res)
                        }
                    }
                }
                catch(err){
                    onRejectedNext(err)
                }
            }
            let rejected = error =>{
                try{
                    if(!isFunction(error)){
                        onRejectedNext(error)
                    }else{
                        let res = onRejected(error)
                        if(res instanceof myPromise){
                            res.then(onFulfilledNext,onRejectedNext)
                        }else{
                            onFulfilledNext(res)
                        }
                    }
                }catch(err){
                    onRejectedNext(err)
                }
            }
            switch(_status){
                case PENDING:
                    this._fulfilledQueue.push(fulfilled)
                    this._rejectedQueue.push(rejected)
                    break;
                case FULFILLED:
                    fulfilled(_value)
                    break
                case:REJECTED:
                    rejected(_value)
                    break
            }
        })
    }
    //catch方法
    catch(onRejected){
        return this.then(undefined,onRejected)
    }
    //静态方法
    static resolve(value){
        if(value instanceof myPromise) return value
        return new myPromise(resolve=>resolve(value))
    }
    
    static reject(value){
        return new myPromise((resolve,reject)=>reject(value))
    }
    
    static all(list){
        return myPromise((resolve,reject)=>{
            let values = []
            let count = 0
            for(let [i,p] of list.entries()){
                this.resolve(p).then(res=>{
                    values[i] = res
                    count++
                    if(count === list.length) resolve(values)
                },err=>{
                    reject(err)
                })
            }
        })
    }
    
    static race(list){
        return new myPromise((resolve,reject)=>{
            for(let p of list){
                this.resolve(p).then(res=>{
                    resolve(res)
                },err=>{
                    reject(err)
                })
            }
        })
    }
   
    finally(cb){
        return this.then(
        value => myPromise.resolve(cb()).then(()=>value),
        reason=> myPromise.resolve(cb()).then(()=>{throw reason})
        );
    }
}
```

