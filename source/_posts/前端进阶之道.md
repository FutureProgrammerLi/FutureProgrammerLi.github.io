---
title: 前端进阶之道
date: 2020-05-20 14:35:31
tags: 浏览器
categories:
- 面试
- 书本
---

### 1.浏览器

#### 事件三个阶段

事件触发： 捕获=》元素本身触发事件 =》 冒泡

element.addEventListener('click',callback, false/true)  //第三个参数表示是否捕获事件,默认为false

event.stopPropagation 阻止事件冒泡(stopImmediatePropagation不仅能,还能阻止同一目标注册的其它事件)

event.preventDefault 阻止默认事件

#### 注册事件的方法

1. DOM2:addEventListener 可以绑定多个事件. 旧版IE对应attachEvent()
2. DOM0: element.onclick(fn) / onblur() / onfocus() 等等
3. 行内绑定: <button onclick="dialogVis = false"\>Click</button\>  

移除事件:removeEventListener(),detachEventListener()

capture:捕获事件  // once: 事件只触发一次  // passive:永不调用preventDefault(?)

#### 事件代理

常见用于ul,ol标签上.   避免将事件添加到每个li上,于是直接把事件绑定在ul标签上

优点: 节省内存. 子节点不需要取消绑定事件,变得更加灵活.

#### 存储

四巨头: cookie, localStorage , sessionStorage , indexDB

* cookie:一般由服务器生成,且之后每次请求都绑定在请求头上.可以设置过期时间.最大4K
* localStorage: 一般是常用的数据信息,不参与请求.除非并清理,否则不会被删除.最大5M
* sessionStorage: 类似localStorage,但当用户关闭浏览器时(?)它就会被清除(session).最大5M
* indexDB:无限(?),除非并清理,否则不会被清除.不参与通信.用于存储大量的数据.

cookie的安全性:

value: 如果是账号密码等重要信息应进行加密.(??把重要信息放在传输过程中!?)

http-only: 若TRUE表示不能用JS访问cookie,减少XSS攻击 (Cross-Site Scripting)

secure: 只有在HTTPS传输协议下才携带该cookie

same-site:有跨域,无cookie. 减少CSRF攻击.(Cross-Site Request Forgery)

`Service Worker`:(在BOM的navigator上)

充当浏览器和服务器的代理,必要时可以缓存资源,判断是否向服务器请求,提高离线体验.

### 2.安全

**主要Cross-Site Scripting (XSS). Cross-Site Request Forgery(CSRF) **

#### 一、XSS: 利用用户对服务器的信任. (改HTML(DOM-Based/反射性),改script(存储型))

"服务器传回来的JS文件和HTML内容都是安全的,那就都执行了吧."

​    防御: 

   1. 转义: 将可能是被修改了的script文本转义(黑名单)

      ```js
      escape('<script>alert(1)</script>')// <>号编程了&lt,&gt
      // -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt;
      ```

2. 添加白名单:

   ```js
   var xss = require('xss')
   var html = xss('<h1 id="title">XSS Demo</h1><script>alert("xss");</script>')
   // -> <h1>XSS Demo</h1>&lt;script&gt;alert("xss");&lt;/script&gt;
   console.log(html)
   ```

   其实两个方法一样,一个黑名单,一个白名单.白名单借助了xss模块.

3. Content-Safety-Policy:

   在HTTP请求中设置Content-Safety-Policy可以选择:只加载本站资源/https协议的图片/全部资源

       ```js
Content-Security-Policy: default-src ‘self’
Content-Security-Policy: img-src https://*
Content-Security-Policy: child-src 'none'
       ```

#### 二、CSRF（Cross-Site Request Forgery） 跨网站伪造请求(?) 利用服务器对用户浏览器的信赖

"客户的请求都是安全的,没有恶意的,那就都回复吧."

概括的说: 假装请求这个,实则请求服务器上另外的不允许访问的资源/甚者破坏服务器.

防御:

1. get请求比post请求更容易攻击,所以服务器端处理get请求可以不对数据进行修改
2. 不让第三方网站访问cookie(?)
3. referer 判断是否为第三方网站请求
4. token,验证码等验证信息.

### 3. 缓存:强缓存,协商缓存

#### 强缓存(本地用)

通过设置响应头Expires**或者**Cache-Control

Expires是到期日期,Cache-Control是时长.

**Cache-Control(HTTP 1.1协议)优先级比Expires(HTTP 1.0协议)高**

```text
Expires: Wed, 22 Oct 2018 08:41:00 GMT      
Cache-control: max-age=30
```

有效期间返回状态码200

#### 协商缓存(强缓存过期了吗?过了就要再请求了)

* 方法1.Last-Modified和If-Modified-Since

If-Modified-Since将Last-Modified的值发给服务器,如果服务器在该值之后对应资源有修改,则返回新的资源.

参与请求的是If-Modified-Since.

* 方法2.E-tag和If-None-Match

If-None-Match将E-tag发给服务器,如果E-tag发生改变,则返回新的资源

**E-tag优先级比Last-Modified高,** 这两个都是值,不过载具不同,版本不同.