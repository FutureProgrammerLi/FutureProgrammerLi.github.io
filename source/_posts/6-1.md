---
title: 6-1
date: 2020-06-01 09:52:50
tags:
- Vue
- 性能优化
categories:
- Vue
- 日记
- 整理
excerpt: 代码/webpack/网页技术优化vue项目
---

## 1.Vue代码层面优化

### 1.区分使用场合

1.1 v-if 和v-show

* v-if 条件渲染,一开始为假的时候直接不渲染该元素.初次渲染比v-show好.适用于渲染条件不常变的情况.
* v-show仅将元素属性display设为none.一般用于需频繁切换是否显示的场景.

1.2 computed和watch

* computed有缓存,当属性的依赖发生改变,(且下一次需要该computed属性的时候?)才进行计算.
* watch一般在某属性变化后,*需要执行比较繁琐的操作*的时候才用.而且能取得变化前后的值(?)

### 2.v-for不和v-if一起用

v-for优先级比v-if高,即如果遍历数据多,v-if就会执行很多遍从而影响性能

```js
//bad
<ul>
    <li v-for="item in users" v-if="item.isActive" :key="item.id" >
        {{item.name}}
    </li>
</ul>

//good
...
<li v-for="item in activeUsers" :key="item.id">
    {{item.name}}
</li>

...
computed(){
    activeUsers(){
        return users.filter(i=>{
            i.isActive
        })
    }
}
```

### 3.避免data里面放太多数据(静态数据的冷冻)

原因:Vue实例里的data数据会被劫持(Object.defineProperty遍历data对象),而一些列表数据可能获取后就不会发生变化.

解决方法:利用Object.freeze()优化(避免静态数据被劫持?)

```js
data:return{users:{}}
created(){
    axios.get('/users').then({data}=>{
        this.users = Object.freeze(data)      //?将冻结了的数据给this.users???
    })
}
```



## 4.销毁实例外的事件监听

原因:Vue实例的事件监听会在destoryed生命周期销毁.而*实例外添加的事件监听并不会被销毁.*

解决方法:在beforeDestroy或destroyed里销毁实例外绑定的事件监听

```js
beforeDestroy(){
    document.getElementById('btn').removeEventListener('click',fn)  
}
```

## 5.图片资源懒加载

借助vue-lazyload插件.在全局注册一下即可.之后在img中用v-lazy代替src

```js
//npm i -D vue-lazyload
//main.js
import VueLazyLoad from 'vue-lazyload'
Vue.use(VueLazyLoad)

//组件中
<img v-lazy='assets/pic.png' >
```

## 6.路由懒加载

```js
//router/index.js
const routes = [
    {
        path:'/Home',
        component:()=>import(/*webpackChunkName:'gourp-1'*/ '@/views/Home')
    }
]
//webpackChunkName我自己没起作用过?!
```

## 7.第三方库按需导入

如各种组件库,element-ui,ant-design-vue 等等.主要针对第三方库.

## 8.大量数据的适量渲染

摘自<前端进阶之道>的面试题.地址见最后

思路是大量数据,每次仅渲染20/30条左右.利用fragment整合数据后再附加(append)到body标签上.

requestAnimationFrame是为了平滑的添加而不出现卡顿.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      控件
    </ul>
    <script>
      setTimeout(() => {
        // 插入十万条数据
        const total = 100000
        // 一次插入 20 条，如果觉得性能不好就减少
        const once = 20
        // 渲染数据总共需要几次
        const loopCount = total / once
        let countOfRender = 0
        let ul = document.querySelector('ul')
        function add() {
          // 优化性能，插入不会造成回流
          const fragment = document.createDocumentFragment()
          for (let i = 0; i < once; i++) {
            const li = document.createElement('li')
            li.innerText = Math.floor(Math.random() * total)
            fragment.appendChild(li)
          }
          ul.appendChild(fragment)
          countOfRender += 1
          loop()
        }
        function loop() {
          if (countOfRender < loopCount) {
            window.requestAnimationFrame(add)
          }
        }
        loop()
      }, 0)
    </script>
  </body>
</html>
```

## 9.服务器渲染和预渲染(SSR & Prerender)

利用Nuxt框架,或者vue-server-renderer插件

* SSR的优点:更好的SEO以及更快的首屏渲染速度.直接从服务器端返回首次渲染好的页面.(无需等待js的下载再进行渲染?)
* 缺点: 对服务器要求高,而且使用的API会发生变化,如没有了beforeCreate和created钩子函数,asyncData(),validate()等等.(nuxt)

## 2.Webpack层面的优化

1. 图片的优化

   * 利用url-loader的limit限制,将小于limit的图片转为base64.针对类似icon等小图片(?)

   * 利用image-webpack-loader对图片进行压缩

     ```js
     {
         test:/.(png|jpg|jpeg|gif),
         use:[
             {
                 loader:'url-loader',
                 options:{
                     limit:8192   //,默认是10000   
                 }
             },
             {
                 loader:'image-webpack-loader',
                 options:{
                     bypassOnDebug:true  //?
                 }
             }
         ]
     }
     ```

     

2. 减少ES6转ES5的冗余代码

   用babel-plugin-transform-runtime将webpack在ES6转ES5时插入的辅助函数变成require的方式引入.

   ```js
   babel-runtime/helpers/createClass
   //=>
   require('babel-runtime/helpers/createClass') //服务器端?
   ```

3. 提取公共代码(? 比如?)

   用Webpack内置的CommonsChunkPlugin插件将公共的代码抽取到单独文件.

   ```js
   module.exports = {
       entry:{
           vendor:['jquery','other-lib'],
           app:'./entry'
       },
       plugins:[
           new webpack.optimize.CommonsChunkPlugin({
               name:'vendor',       //对应entry里的名字
               //minChunks:Inifinity  //Ensure no other module goes into the vendor chunk(?)
               minCunks:function(module,count){
               return {
                   module.resource &&
                   /\.js$/.test(module.resource) &&
                   module.resource.indexOf(
                   path.join(__dirname,'../node_modules')
                   ) === 0
               }
           }
           })
           new webpack.optimize.CommonsChunkPlugin({
            name:'manifest',
            chunks:['vendor']  //?抽离代码模块的映射关系?
           })
       ]
   }
   //详见 https://webpack.js.org/plugins/commons-chunk-plugin/
   ```

4. 模板预编译,vue-template-loader, >"构建的时候就把模板编程渲染函数".(构建是什么时候?)
5. 提取组件的CSS mini-css-extract-plugin
6. 优化SourceMap

## 3.基本Web技术优化

1. 使用CDN.

2. 开启gzip.利用compression插件(?为什么是服务器端?服务器端压缩响应吗?)

   ```js
   //express项目中的main.js
   const compression = require('compression')
   const app = express()
   app.use(compression())
   ```

3. 利用缓存.  强缓存和协商缓存的策略.
4. 利用调试工具查找项目性能瓶颈.



[1] 文章内容来自

https://mp.weixin.qq.com/s/teJPy9D5gp2zshfIOts2mQ

[2]前端进阶之道:[https://www.yuchengkai.cn/docs/frontend/performance.html#%E9%9D%A2%E8%AF%95%E9%A2%98](https://www.yuchengkai.cn/docs/frontend/performance.html#面试题)