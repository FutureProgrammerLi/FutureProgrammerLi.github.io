---
title: 深入理解es6-3
date: 2019-12-27 19:34:34
tags: 
- Javascript
- 深入理解ES6
excerpt: ES6中函数的新特性(箭头函数/默认参数等)
categories: 
- 书本
---
## 深入理解ES6第三章 函数
### 1. 默认参数     
ES5==>      
```
time = params || 200   
```

==>params是传入的,没传进来就用200 
ES6 ==>      
```
function test(params=200)
{ var time = params}
```
区别 function test(url, time=200,callback){}     ==> **默认参数不一定要摆在最后.   !区别于展开运算符...arg作参数**
==>function test('/foo',undefined)     ==>time = 200
==>function test('/foo',null)               ==>**不使用默认值**
---
### 2. arguments  
ES5非严格模式,arguments数组会因变量变而变 arguments[0]  arguments[1] 4个true
                             严格模式 变量改变,arguments不会变          2true 2false
                      **ES6用默认参数, 行为类似ES5的严格模式,默认参数不在arguments中,变量变了arguments内容也不会变,保存刚传进来的,实际的参数（不包括默认参数）**
```
function mixArgs(fir,sec){
    "use strict" 
    console.log(fir ===arguments[0]) //true
    console.log(sec === arguments[1]) //true
    fir = "c"
    sec = "d"
    console.log(fir ===arguments[0]) //false
    console.log(sec === arguments[1]) //false
}
mixArgs("a","b")   //说明arguments[]的内容没有改变
```

**arguments数组内容总是存储传进来的实际的参数,并不是固定的**
**有默认参数,实际没传进来的,argument.length不把那个算入**


function add(first, second=getValue()){}
                                        getValue只有在add不传入第二个参数时才被调用
(first , second = first)           ==>对

(first=second, second)         ==>错  //顺序问题
add(1,1) 不报错,没有用默认值   add(undefined,1)报错    ??!!用了默认值?

函数的length属性统计函数命名参数的数量               //命名参数和不定参数是两个东西
`function fn(命名参数\*n,不定参数\*1)`
不定参数不包括在length属性中      
pick(object,...arg)   ==>pick.length = 1
不定参数限制:
1. 一个函数只能有一个展开运算符, 而且**必须放在所有参数的末尾**
2. setter中不能用...运算符( 传多个给set，setter会蒙)元操作你给我宏数据??!!

展开运算符 :例子    Math.max(...values)       <==>     Math.max.apply(Math,values) //利用apply将this指向Math,将values传入???还不是传了个数组进去？
apply不能传数组??将数组解构了??
`apply第二个参数有解构功能,是展开运算符的祖先`

Math.max(...values,0)     ==>不会报错,是展开运算符      
展开运算符,默认参数不一定要放在所有参数后面
不定参数必须放在所有参数后面！！！
---
### 3. 函数的name属性
1. 函数声明和函数表达式
```
var announce = function exp(){
         //announce是声明的名字,exp是表达式名字,表达式的比声明的权重大.
         //同时有,name取exp,只有annouce,name值为annouce
}
```
对象方法,getter和setter函数会有get functionName 和set functionName
bind生成的有bound,匿名的有anonymous前缀
**所以name的值并不准确**

---
### 4. 函数的[[CALL]]和[[CONSTRUCT]]
1. 不是所有函数都有[[CONSTRUCT]]方法,具有[[CONSTRUCT]]方法的都叫做`构造函数`
   能new的,都先[[CONSTRUCT]]再执行[[CALL]]
2. 判断是否用某个构造函数创建实例
   ```
   function Person(name){
       if(typeof new.target === Person){   //不是用new创建,new.target的值会为undefined
           this.name = name
       }else{
           throw new Error('必须通过Person来创建实例!')
       }
   }
   ```
3. 偏题,块级函数

  同理于let和const,出了块就访问不到了.
  ES5的严格模式下:
  不同的是,*let不会提升,块级函数会提升至块的顶部*
  ```
  "use strict"
  if(condition){
      console.log(typeof doSomething)
      let doSomething = function(){
          //..
      }
  }     //*抛出错误*
  ```
  **ES6中,块级函数会被提升到全局作用域下**
---
### 5.箭头函数
1. 书本内容:
    1.1 this,super,arguments,new.target的值由外围最近一层非箭头函数决定
    1.2 不能通过new调用 *即用即弃*
    1.3 没有原型
    1.4 this只能指向最近外围函数,不能改变绑定
    1.5 只能命名参数和不定参数,arguments`不是函数自身的`,总能获取最近一层非箭头函数的arguments对象.
    1.6 不支持重复的命名参数 //普通函数非严格模式可以
2. 一般语法 
```
let arrFun = () => { ... }
```

   返回对象:
   ```
   let getTem = id => ({ id:id,name:"Temp"}) *括起返回的那个对象*
   ```

   立即执行函数 
   ```
   ((arg)=>{
       return{
           getName:function(){
               return name
           }
       }
   })("Nicholas")      //小区别于普通函数创建的
   ```

3. 怎么识别是箭头函数?
  typeof instanceof Function bind,call,apply都可以用
  **为了简写而不是区别**

  ### 6.尾调用优化
  1. 条件:
    1.1 不访问当前栈帧的变量(即不可是闭包)
    1.2 函数内部,尾调用是最后一条语句
    1.3 尾调用的结果作为函数值返回 (*返回一个函数?*)
  2. 案例
  成功案例
  ```
  function factorial(n,p=1){
      if(n<=1>){
          return 1*p
      }else{
          let result = n*p
          return factorial(n-1,result)
      }
  }

  function fn(){
      return anotherFn() //无返回
  }
  ```

  失败案例:
  ```
  function fn(){
       anotherFn() //无返回
  }

  function fn(){
      return 1+anotherFn() //执行了其它操作
  }

  function fn(){
      var result =  anotherFn()
      return result     //调用不在尾部(?)
  }

  闭包
  ```

 





