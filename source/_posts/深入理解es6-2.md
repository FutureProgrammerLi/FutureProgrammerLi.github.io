---
title: 深入理解es6第二章
date: 2019-12-27 19:05:46
tags: 
- Javascript
- 深入理解ES6
excerpt: 字符串和正则表达式
categories: 
- 书本
---
## 深入理解ES6第二章
### 字符串和正则表达
*BMP （Basic Multilingual Plane)基本多文种平面*, 16位编码表示的文字
普通一个16位字符表示，特殊要两个16位表示.
字面看length是1,实际是2，用了两个位置存储该字符
charCodeAt('')         ==>charPointAt('')  用于正确识别一个超出16位字符表示的字符
测试是否为32位编码数   ==>   
```
function test(c)
{ return c.charPointAt(0) >0xFFFF}  
```
  测试c字符是否为32位编码
相对 String.fromCodePoint('134071')      ==>将编码变为字符串

对比字符串时，需要标准化为同一种形式.(ae和音标半个ae是等效的)     ==>normalize() ==>不添加参数默认为'NFC'形式

### 字符串方法:
1. includes()    startsWith()  endsWith()     
 两个参数,内容和索引值(搜索起始位置/endsWith则倒序（从索引值减去内容长度,正向匹配?)
 *内容只能传字符串，不能传正则*
  indexOf和lastIndexOf可以,转成字符串再搜索
2. repeat方法 
==>"abc".repeat(3) ==>abcabcabc(用于缩进)

### 正则表达 *修饰符
1. u修饰符  
==>用于填补匹配两个编码单元的字符的缺陷
==>正确识别看上去单字符，实际length值为2的字符  
==>/^.$/u.test(text)         
==>修饰符都是可选的,initial,i,global,g,unicode,u
2. y修饰符   
==>粘滞修饰符   
==> lastIndex和sticky属性的问题
==>无修饰符则无视lastIndex,g和y则继续往后找,    0,7,7  ==>0,14,14 ==>无修饰符,g,y的结果
*重新找和继续找的区别*
exec,test才会用到lastIndex属性
检测u,y修饰符 
```
try {
    var pattern = new RegExp('.','y'); 
    return true
    } 
catch(ex){
    return false
    }                
```
主要是RegExp对象的第二个参数
3. flags属性,直接获取修饰符。
即/abc/iguy         ==>这里的iguy
ES5的做法   
```
text = a.toString()  //a是正则
return text.substring(text.lastIndexOf("/")+1,text.length)  //直接取最后一个斜杠后面的字符串
```

substring参数(start,stop) ==>stop随便整个,不超范围就行，反正修饰符肯定没有整个串长
ES6新增 source和flags 访问器属性,
source返回要匹配的正则/内容,   flags返回修饰符
```
var text = /abc/iguy       
console.log(text.source,text.flags)    // abc iguy
```

4. 正则复制
```
   var re1 = /ab/i; 
   var re2 = new RegExp(re1,'g');          
```
   ==>re2  = /ab/g        //*注意,修饰符会被修改*

5. 模板字面量：用反引号声明字符串，变量值      `Hello World` 
用处（1） 换行 ES5之前  字符串拼接 ==>    ['Mul','String'].join("\n")   或者 "Mul \n" + "String"
ES6中    
```
 `Mul
                                       String` 
```
      ==>直接回车，而且回车之后的空格还会记入串长度length.
也可以直接 `Mul\nString` ,可读性不高
字面量中的变量 ==>${name}     ==>var name ='Nicholas'      ==>Nicholas
没理解到:     message = `${count} items cost $${(count * price).toFixed(2)}
   其中一个原型输出$,另一个为占位符${(count * price).toFixed(2)}

6. 标签模板  
```
*var mes = tag`Hello World`*
```
   ==>定义一个函数处理字符串
function tag(literals,...substitutions){}
literals是数组,存字符串           
substitutions存解释值(变量),但被解构,以多个参数形式传入
实际text=\`${count} items cost $${(count * price).toFixed(2)}.\`
literals = ["","items cost $","."]      ==>变量前中后的字符串
...substitutions = (10,2.50)     ==>经计算后的值
literals总比substitutions多一个元素  literals[0]代表开头 , literals[literals.length-1]代表结尾
利用这两个参数可以拼凑成完整字符串,
默认行为可以具体在函数中写出来.
String.raw()方法



