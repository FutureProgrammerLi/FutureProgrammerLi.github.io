---
title: 深入理解es6-6
date: 2019-12-28 08:59:50
tags: 
- Javascript
- 深入理解ES6
excerpt: symbol值和symbol属性
categories: 
- 书本
---
### 深入理解es6第六章 symbol
#### 一、Symbol值 
##### Symbol创建
```
let name = Symbol('description') //调用toString方法会返回description,但不能直接访问[[Description]]内部属性
//或者
let sth =new Symbol('description') 
```

#### Symbol共享体系
*为了将多个不同类型对象用同一个symbo来表示一个独特的标识符?*
**Symbol.for('description') 创建在Symbo注册表中,以description为键名,值为symbol的symbol**
```
Symbol{
    description:symbol   //只是帮助理解
}
```
`只有用Symbol.key创建的,才能被共享` 
可以用Symbol.keyFor('sth'),根据变量名获取全局symbol注册表下的键名

#### Symbol不能被类型转换,只能String(uid),获得自身描述//Symbol(uid)
### Object.keys(),Object.getOwnPropertyNames()返回对象的键和自身属性值,*后者不考虑可枚举性*(enumerable)
#### Object.getOwnPropertySymbols()返回键为symbol的值,是一个数组
---
##### Symbol属性
*1.改写Symbol.hasInstance()属性,将普通对象改为特异对象*
```
function specialNumbers(){} 
Object.defineProperty(specialNumbers,Symbol.hasInstance,{ //改变instanceof 的默认行为
    value:function(v){           
        return(v instanceof Number)&&(v>0&&v<=100))
    }
})
var two = new Number(2),
    zero = new Number(0)
console.log(two instanceof specialNumbers)
console.log(zero instanceof specialNumbers)
```
---
*2.Symbol.isConcatSpreadable,看不懂*
---

*3.改写Symbol.match(),replace,search,split方法*
```
let hasLengthOf10 = {
    [Symbol.match]:function(v){
        return v.length === 10?[v],null;   //为什么是[v]?
    },
    [Symbol.replace]:function(v,re){
        return v.length === 10?re,v
    }
    //...其它同理
}
```
---

*4.Symbol.toPrimitive() 根据传入值的类型调用不同的方法*
大多数标准对象,*数字模式下*
1. 调valueOf(),看是否为原始值
2. 调toString(),看是否为原始值
3. 抛出错误

而在字符串模式下
1. 调toString(),看是否为原始值
2. 调valueOf(),看是否为原始值
3. 抛出错误
举例说明
```
function temperature(degrees){
    this.degrees = degrees
}
temperature.prototype.[Symbol.toPrimitive] = function(hint){
    switch(hint){
        case 'string':
           return this.degrees + '\u00b0';
        case 'number':
           return this.degrees;
        case 'default':
           return this.degrees +'degrees!'
    }
}
```
---
*5.Symbol.toStringTag()修改Object.prototype.toString()方法返回的值*
一般,用Object.prototype.toString().call(xxx)可以检测xxx的类型.
```
 Object.prototype.toString.call(undefined);//”[object Undefined]”
 Object.prototype.toString.call(“abc”);//”[object String]”
 Object.prototype.toString.call(123);//”[object Number]”
```

但改了这个方法,就`变得不可靠了`
```
function Person(name){
    this.name = name
}
Person.prototype.[Symbol.toStringTag] ="Array"
Person.prototype.toString = function{
    return this.name
}
var me = new Person('Li')
console.log(me.toString())     
console.log(Object.prototype.toString().call(me))   //Array,明显是错的, 真的数组会返回[object Array]
```
*甚至修改原生对象上的toStringTag()...人干事???*
`Array.prototype.[Symbol.toStringTag]='magic'`
---
#### 插曲,with语法
```
var colors = ['red','green'],
			    color = ['black','pink'],
				val = [1,2,3]
			with (colors){
				push(color)    //black,1,pink,2还是black,pink,1,2,3?
				push(val)     //代替不了concat,单线程,color[2]是个数组
			}
			console.log(colors)
```
*6.[Symbol.unscopable],在with语句中标识出不创建绑定的属性名(?)*

