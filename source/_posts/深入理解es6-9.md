---
title: 深入理解es6-9
date: 2019-12-30 13:46:09
tags: 
- Javascript
- 深入理解ES6
excerpt: ES6中类的使用
categories: 
- 书本
---
## 深入理解es6 第九章 类
### 类的声明
```
class Person{        //整合了构造函数(创建属性)和方法添加(创建方法Person.prototype.sayName)
    constructor(name){         //构造函数,用于区分其它的函数[[CONSTRUCTOR]]
        this.name = name;
    }
    //等价于Person.prototype.sayName = function(){console.log(this.name)}     ES5做法
    sayName(){
        console.log(this.name)
    }
}
console.log(typeof Person)      //"function"
```
*建议*:所有自有属性都在构造函数中创建,便于控制. (还可以通过自有方法创建属性)
---
### 类的特点
1. 类的声明`不会提升`
2. 所有类声明代码`自动运行在严格模式下`
3. 类的所有方法都是不可枚举的(for-in?)
4. 每个类都有[[CONSTRUCT]]内部方法,new调用的就是这个方法
5. 类只能用new创建实例(?还有其它方法创建实例?修改指针指向?)
6. 类中修改类名会报错

### 用自己的语言编写一个类
```
let Person = (function(){     //let **特点1**
    "use strict"       // **特点2**
    const Person = function(name){         //特点4
        if(typeof new.target === "undefined"){
            throw new Error("必须通过new关键字创建实例")      // **特点5**
        }
        this.name = name;
    }
    Object.defineProperty(Person.prototype,"sayName",{
        value:function(){
            if(typeof new.target === "undefined"){
              throw new Error("必须通过new关键字创建实例")      // **特点5**
        }
            console.log(this.name)
        },
        enumerable:false,                //**特点3**
        writable:true,
        configurable:true  
    });
    return Person;
}())          // **是立即调用函数,所以不能可以在外部修改类名而不可以在内部修改(??)
              //内部的Person用const声明,故不可修改,而外部的Person用let声明,所以可以修改???
              //我构造函数跟类不同名呢??
```
**方法相当于添加到该类名的prototype上,上例就是Person.prototype.sayName = function(){}**
---
类表达式和命名类表达式
跟函数一样
```
let PersonClass = class{};  //匿名类表达式
let PersonClass1 = class PersonClass2{}  //命名类表达式
//???
console.log(typeof PersonClass2)  //undefined?????是的
console.log(PersonClass.name)      //PersonClass2
```
---
**为什么????**
```
let what = class Cl{}	
console.log(typeof Cl) //undefined

class Cl{};
console.log(typeof Cl) //function
```
---
### 一等公民:一个可以传入函数,可以从函数返回,并且可以赋值给变量的值
1. 创建单例? let person = new class{
    //..类的定义,constructor和方法等
}("Nicholas")
只创建一个为什么要定义类?
2. 类的访问器属性一般不在构造函数内,
```
let person = {
    constructor(){

    }
    get html(){},
    set html(value){}
}
Object.getOwnPropertyDescriptor(Person.prototype,"html") //?什么意思?
```
**类方法和访问器属性也支持使用可计算名称**
---
### 类的静态方法(静态变量呢?)
**JS没有静态变量**
1. 类的声明内,在对应方法前加static关键字
2. 静态方法不用创建实例就可以调用,直接 [类名].[方法名]即可调用
3. static不能修饰constructor函数
4. *实例中不可以访问静态成员*
---
### 类的继承和派生类
以前的做法:
```
function Rectangle(length,width){
    this.length = length;
    this.width = width;
}
function Square(length){
    Rectangle.call(this,length,length)
}
```
现在的做法:
```
class Square extends Rectangle{
    constructor(length){
        super(length,length)  //?怎么理解?相当于Rectangle.call(this,length,length)
    }
}
```
不声明constructor,只用extends,参数就会默认是父类的个数:
```
class Square extends Rectangle{
    constructor(...args){
        super(...args)
    }
}
```
#### 使用super()的小Tips
1. 有super()的,类声明中`必须要有extends`;
2. 构造函数里要用this的话,必须在此之前调用super(),`初始化this`,不初始化就报错;
3. 不调用super(),就在构造函数上返回一个对象(?)
---
#### 类方法的屏蔽和调用
1. 派生类内写个跟父类一样的函数,调用时就会用自己的了
2. 在父类的基础上修改方法,可以:
```
//子类定义中
getArea(){
    super.getArea()     //调用父类的同名方法
    //...       自己的修饰
}
```
---
`继承来的静态方法,尽管是用派生类构造的实例,instanceof 派生类名 返回的是false.`
用的还是父类的静态方法吗?
```
var rec = Square.create(3,4);          //create()是父类中定义的静态方法
console.log(rec instanceof Square);    //false
```
---
### 内建对象的继承
1. 插曲: 数组的值和length的关系
   直接改length可以数组的值的个数,传统做法用apply并不能实现
   ```
   let arr ={
				2:3,
				3:4,
				length:2,
				__proto__:Array.prototype
			}
	console.log(arr);//[empty × 2, 2: 3, 3: 4]   length=5
	arr.push(6);
	arr.push(8);
	arr.push(9);
	console.log(arr); //[empty × 2, 6, 8, 9]     length=5
    ```
    `length = 5,注释掉push之后length=2`
2. ES5和ES6中继承的区别(造成不能继承功能的原因)
ES5中:
`派生类创建this值,调用父类的构造函数.(this被父类修饰?)`
ES6中
`父类创建this值,派生类的构造函数修改这个值` (???)
3. Symbol.species属性的运行(不是很懂?)
```
class MyArray extends Array{
    static get [Symbol.species](){
        return Array
    }
}
let i = new MyArray([1,2,3]),
    subi = i.slice(1,3)
console.log(i instanceof MyArray)     //true
console.log(subi instanceof Array)     //true
console.log(subi instanceof MyArray)    //false
```
`所有返回数组的继承方法将使用Array的实例而不使用MyArray的实例`
`subi 是返回回来的数组,所以会用到Symbol.species方法`
---
#### 在类的构造函数中用new.target
1. 构造函数用了new.target判断的类,new一个该类,会返回true
2. 派生类用super()改变this时,若自身没有再判断,一般会返回false
#### 抽象类的实现
```
class Shape{
    constructor(){
        if(typeof new.target==="Shape"){
            throw new Error("该类不能用new创建实例!")
        }
    }
}
```

