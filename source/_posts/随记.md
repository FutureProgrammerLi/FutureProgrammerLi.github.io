---
title: 随记
date: 2020-05-27 12:28:56
tags:
- Javascript
categories:
- 整理
excerpt: Array.prototype.map&reduce , Vue一些面试题
---

## Array.prototype.map()

> ```
> arr.map(function callback(currentValue[, index[, array]]) {
>  // Return element for new_array 
> }[, thisArg])
> Array.prototype.map(cb,thisArg)
> ```

* 外层2,内层3

* 接受**两个**参数,一个callbackFunction,一个this指向

  1. callbackFunction又接受三个参数: 当前遍历的值,索引以及数组全部.

  2. this用于修改callbackFunction里面的this指向(?).不传这个值`this`就为undefined.

     > 执行callback函数时值被用作this
     >
     > Value to use as `this` when executing `callback`

* 数组中undefined的值也会执行callback, 而empty的不会(使用了delete的结果)
* 处理的是调用map时, arr的一个snapshot, arr之后的改变都不会影响map的结果(?说了跟没说一样?)

## map和forEach的区别

同:

1.  都会遍历数组

2. **接收的参数一样!!!!Array.prototype.forEach(callback,thisArg),     callback(currentValue,index,self)**

不同:

1. map会返回一个经遍历处理的数组,forEach返回undefined(map 备份修改, forEach可以直接修改本体)

2. map不会修改原数组,forEach可以 , 在callback里面 arr[index] = currentValue / 2 => arr的每个元素就会缩小一倍.

---

## Array.prototype.reduce()

> ```
> arr.reduce(callback( accumulator, currentValue[, index[, array]] )[, initialValue])
> ```

* 外层2,内层4,内层多了个base

* 接受**两个**参数: reducerFunction,initialValue/base

  1. reducerFunction接受**四个**参数:累加器/初始值, 当前遍历的值,索引值,数组本身

     ​                                                 (accumulator/base  currentValue currentIndex     Source Array)

* 2. initialValue: 累加器一开始的值,

      如果设置了.reducerFunction里的accumulator就为它,currentValue就为数组的第一个值;

     如果没设置,reducerFunction第一次accumulator就为数组第一个值(0为特殊情况),currentValue就为数组第二个值.

     **0作为第一个值的时候好像有点问题?**

* 3. *accumulator只会在第一次中不为undefined(initialValue或为数组第一个值) , 之后都为undefined*

### 问题引入(万恶之源) 

```js
const arr = [0,1,2,3,4]
const reducer = (acc,item)=>acc?(acc.toString()+item.toString()):item.toString();
console.log(arr.reduce(reducer))   //数组的第一项0没有参加运算
console.log(arr.reduce(reducer,0)) //这里的initialValue 没参加reducer
//arr.reduce(reducer) ==>
//const anotherArr = [1,2,3,4]
//anotherArr.reduce(reducer,0) 
```

错误答案:  01234,001234

正确答案:1234,01234

0作为acc/数组第一项的时候是不是有点问题??

```js
const arr1 = [2,1,2,3,4]
console.log(arr1.reduce(reducer))     //21234    (???)
console.log(arr1.reduce(reducer,0))   //21234
```

摘自MDN:

>**Note:** If `initialValue` is not provided, `reduce()` will execute the callback function starting at index `1`, skipping the first index. If `initialValue` is provided, it will start at index `0`.

## null和undefined的区别

1. typeof undefined   => undefined

   typeof null => object

2. undefined == null     =>true     都被转换成0

   undefined === null =>false

3. ​    5+undefined         ==> NaN           Number(undefined) -> NaN

   ​    5+ null                   ==> 0                    Number(null)=>0

4.    undefined == null == false

5. undefined 代表此处可以有值但还未定义

   null代表此处不应该有值

6. 默认参数

   ```js
   function test(num=1){
       console.log(typeof num)
   }
   test(undefined)      //number ,num is set to 1
   test(null)           //object, num is set to null
   //如何不使用默认参数
   ```

   