---
title: 深入理解es6-7
date: 2019-12-28 10:32:54
tags: 
- Javascript
- 深入理解ES6
excerpt: Set & Map
categories: 
- 书本
---
### 深入理解es6第七章 Set和Map
#### Set:无重复值的数组
#### Map:键值对
**所有用对象作为键名的,其实都是同一个键值对,所以会被覆盖**
*一般的类数组:*
```
let key={obj:1},key2={sth:2}
let map = Object.create(null)
map[key]="foo"
map[key2]='oof'
console.log(map[key])   //oof,对象都被转换为[object Object]作为键名
```
*还不能用点号引用属性!!!必须中括号*
---
### Set
#### 特点: 
键名不会类型转换, 两个对象两个键值对,map[5]和map["5"]也是两对(但set中+0和-0是相等的)
不能按索引访问对应值,只能用has判断
#### 方法:
1. 创建
```
let set =new Set("5")  //只能接受字符串或者数组,解决了new Array(5)这种创建长度为5的数组的低可读性
```
**不能创建指定长度的set**
2. add()添加 / size 获取长度,是属性 / has() 检索是否存在 / delete() 删除对应值 / clear() 清空
3. `Set.forEach(value,key,ownSet)` 第一二个参数相同,第三个是自身全部
#### 数组转set去重
```
let a = [1,2,3,4,4,4,4]
let result = [...new Set(a)]
console.log(result)
```
##### WeakSet
1. 特点:普通set都是强引用,值为对象的,指向空之后,set里面仍然保留引用 *存了起来,没有回收*
        WeakSet里面不能有原始值,只能是引用类型的值,是弱引用
**都是对象的数组**
```
//普通set
let set = new Set(),
    key = {}
set.add(key)
key=null       //指向了空
set.size()      //1
key = [...set][0] //从set里面重新获取引用
```

```
//WeakSet
let set = new WeakSet(),
    key = {};
set.add(key);
key=null;
console.log(set.size);      //0?Maybe
key = [...set][0]; //报错,not iterable
```
2. 方法:
add() / has() / delete() //只能添加对象类型,非则报错,false,false
3. 书本:
  3.1 *无法通过程序本身检测自己的内容*
  3.2 不可迭代,不能用for ... of
  3.3 不支持forEach()方法,没有size属性

---
### Map:存储多个键值对的有序列表
1. 键是否相同用Object.is()来判断,极为高级准确
2. `方法`
  2.1 自带方法
   get(key) 根据键名获取值 / set(key,value) 设置 / has() 根据键名判断是否存在 / delete() 根据键名删除键值对 / clear() 清空
  *get方法包含了has?* 没有,get不到会返回undefined, has会返回false
  2.2 初始化
  ```
  new Map([name:"Li"],[age:22]) //一个键值对一个数组
  ```

  2.3 forEach方法,同理于set的
  ```
  map.forEach(function(value,key,own){

  })
  ```
  *可以指定第二个参数作为回调函数的this值*
  #### WeakMap:键名都是对象的键值对集合
  `方法`
  1. set(),get(),has(),delete()  //区别于WeakSet
  2. 用途
    2.1 存储DOM元素,页面上元素被删除,Weak Map里的引用也跟着被删(键空了,整个对都没了)
    2.2 私有对象数据(仅用IIFE因不知何时销毁对象而一直保存数据)????
  3. 选择
  用Map:键是*非对象类型*,支持forEach,size,clear等方法属性
  用WeakMap:只用对象作为键名,*及时回收,避免内存泄漏*


