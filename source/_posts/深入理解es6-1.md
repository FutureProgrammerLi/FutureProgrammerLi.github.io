---
title: 深入理解es6
date: 2019-12-27 18:48:17
tags: 
- Javascript
- 深入理解ES6
excerpt: var/let/const 和块级作用域等
categories: 
- 书本
---
# 深入理解ES6第一章
## var,let,const
### 1.变量提升
```
if (condition)
{var value = 'blue'} else {return null}
```
```
var value //提升
if(condition){ value = 'blue'}   else{return null}
```
else中可以访问value ,但值是undefined
### 2.块级作用域(函数内部,{}之间)
```
function getValue(condition){
if(condition){ 
console.log(value);
let value = 'blue';} //console.log(value)
else{return null}
}        //报错 cannot access before initialization.    同样,else里也访问不了value值,value is not defined
```
==>只有在if内能用value值,else里也用不了. 
==>尽管在同一个函数内,但也访问不了. 优先级  {}>同一个函数内
声明 ==>   var value              初始化 ==> value ='blue'
### 3.禁止重声明：
同一作用域内用var和let声明同一个变量，const同理
可以在内嵌作用域中用let覆盖全局中的var声明
*const必须声明时初始化,否则会报错。*即const name //错
                                               const maxItem = 20; //对
既有变量不能变为常量. 即var,let声明的,不能又用const再次声明（同理于重声明?)
*const声明对象可以修改对象值但不能修改对象绑定(?)*
```
const person ={name:'Nicholas'}
person.name = 'Greg';      //不会报错
person = {name:'Greg'}  //报错 
```
(怎么理解对象的绑定?)
可以改对象内容但不能重新声明一个对象 const 右边不能又是对象
### 4.循环中的变量,函数
变量var出了循环还能被访问，是循环结束时的值.
let声明的出了循环就无法被访问了

立即调用函数表达式(Instant Invoke Function Expression)
```
            var funcs = []
            for (var i = 0 ; i<10;i++){
                funcs.push((function(value){
                    return function(){
                        console.log(value)
                    }
                }(i)))
            }
            funcs.forEach(function(funcs){
                funcs()
            })
```
强制生成计数器变量的副本(?),将每次的i赋值给value(副本?闭包保护?),从而输出0-9
简化版:
```
for(let i =0 ;i<10;i++){
console.log(i)}
```

*for(let key in object)遍历对象属性同理,不用let则全是最后一个属性(ccc)*
### 5.var弊端:会覆盖全局变量
```
var RegExp = 'Hello'
var ncz = 'Hi' //两个都是window对象原本就有的属性,但值会被覆盖
console.log(window.RegExp) ==>'Hello'
```
let和const则*只会遮蔽全局变量而不会覆盖*
```
let RegExp = 'Hello'
console.log(window.RegExp ===RegExp)
console.log(RegExp) //自己声明的
console.log(window.RegExp) //全局自带的
```


