---
title: 随记
date: 2020-04-29 13:25:01
tags: 
- HTML
- CSS
- Javascript
- Vue
excerpt: HTML&CSS&JS 知识点整理
categories:
- 合集
- 随记
---
## HTML
1. HTML语义化的好处?
    (1) 页面结构清晰,可读性高. 便于团队的维护和开发
    (2) 有利于SEO (Search Engine Optimization),提高网页流量(?)
    (3) 能提高页面渲染速度(DOM Tree渲染), 浏览器不用花时间判断标签名是否符合W3C标准.(老熟人了)

(TODO 浏览器页面渲染过程)
    ===
## CSS
1. 清除浮动的方法:
    (1)父元素中设置 overflow:hidden;
    (2)浮动元素结尾增加空标签(或空的块元素). 样式设置clear:both;
    (3)父元素中设置: .clearfix:after{content:''; display:table; clear:both;}
2. 隐藏一个元素的方法:
    (1)display: none; 
    (2)visibility:hidden; *visibility:collapse,一般元素,等价于visibility:hidden.table相关元素则会与display:none效果一样.*
  * 区别是(1)不会分配空间,(2)会
    (3)opacity:0;
3. 元素置中的方法:
3.1 水平居中
```css
/* 方法一 */
/* 块元素 */
{
    margin:0 auto;
    width:200px;  /* 宽度是必须的 */
}
/* 行内元素 */
{
    text-align:center;
}
/* 或者强行改display属性,再对应使用(?意义呢?) */

/* 方法二 */
{
    display:flex; 
    justify-content:center; /*元素自身样式上*/
}
```

3.2 水平垂直居中
```css
/* 方法一、 flex布局 */
.parent{
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
}
/* 方法二、父相子绝 */
.parent{
    position:relative;
}
.child{
    position:absolute;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
}
/* 方法三、同理于2 */
.parent{
    position:relative;
}
.child{
    position:absolute;
    top:0;right:0;bottom:0;left:0;
    margin:auto;
}
/* 方法四、table */
.parent{ 
    display:table-cell;
    vertical-align:center;
    text-align:center;
}  
```
4. 选择符有哪些?优先级如何?权重计算又是怎样的?
ID选择器,类/伪类选择器,属性选择器,元素/伪元素选择器,通配符选择器
#id,.class/:pseudoClass  [attribute]  div,         *
!important > 行内样式 > # > . > element > *
最大           1000    100 10    1        0
例如 body #darkside .sith p {}     权重(1+100+10+1=112)
     li.red.level{}      权重(1+10+10=21)
延申用法:
4.1 div.container=> container类里的div
4.2 .container div {} => 空格用法.container里面的所有div.**与上面的区别是不包括container本身**
4.3 .container > div => container里面**第一层**的所有div
4.4 .container + div => `与container同一层的,紧接着的那一个div`, 如果紧跟的不是div元素,则该样式会被忽略
4.5 .container ~ div => 与container同一层的,后面所有的div.`紧跟的可以不是div,样式也不会被忽略`
4.6 属性选择器 a[title="sth"]{} => 带有属性title=sth的a标签

5. 盒子模型都有哪些?
    (1)标准盒模型(content-box)
    (2)IE盒子模型(border-box)
**区别是(1)按内容大小计算盒子大小,内容改变会把盒子撑大. (2)设置的宽高就是盒子的大小,不随内容改变.**
6. 常见属性取值:
display: block / inline / inline-block / flex / none (/ list-item / table / inline-table)
            (**inline元素无法设定宽高.inline-block既可以设定元素宽高,又可以与其它元素并排**)
position: static(默认) / relative / absolute / fixed / sticky / inherit (page?)
* 定位原点:relative相对自身本应的位置.
          absolute相对父元素(?向上最近一级position为relative或absolute的父元素)的左上角.
box-sizing: content-box(默认) / border-box

7. 为什么要初始化CSS样式?
浏览器兼容问题,某些标签的默认值会因浏览器不同而不同.

===
## JS
一句总结一份题
* 箭头函数总是指向上一层的非箭头函数且不可改变, obj = {a:1 , prop:function return ()=>{console.log(this.a)} } //解决方法
* 实例无法调用静态方法;
* 可以改变length属性从而删除/截取数组;
* 数组push方法返回数组长度length;
* 对象[Symbol]属性不可枚举,可用Object.getOwnPropertiesSymbols()列举.



## Vue



1. 组件传值
1.1父传子: 
父组件 <son :sonData=parentData> ; 
子组件 props:{sonData:{type:Number, required:true , default:10}} //props:['parentData']
或不用在props注册,直接$attrs.sonData==>值则为parentData
// props / $attrs / $refs  / $children
1.2子传父: 
子组件: this.emit('sonFunc',sonData); 
父组件 <son @sonFunc=parentFunc(sonData)> 在parentFunc里面就可以获取子组件的值
1.3 兄弟组件
* emit也适用
$parent / $root 借助祖先组件通信
provide(){ 
    return {prop}
} 
inject:['prop']  //所有后代都可以获取

2. v-slot
    匿名插槽 <component-a v-slot:default /> ==> <slot></slot>
    具名插槽 <template v-slot:content>... </template>  ==> <slot name="content"></slot>
    作用域插槽: 子组件的数据经父组件处理输出最终结果
    子组件<slot name="sth" :xx="xx">   父组件 <component-a v-slot:sth="props_slot"> {{props_slot.xx}} </component-a>
    (第一个xx是子组件的数据,第二个呢?)(props_slot是个对象)
    第一个是给props_slot对象添加属性的键,第二个是子组件的值?
    如果:abc = "xx" 则props_slot.abc =  子组件xx的值

3. v-if 和 v-show的区别?

  相同: 都是控制元素是否显示 	

  不同: 1.v-if根据条件选择性渲染,DOM树上甚至可能不出现该元素.

  ​             v-show修改display的值为none.

  ​        2.因此: v-if有**更高的切换成本**,适合改变可能性小的场景;v-show**重复切换成本较低,初次渲染成本高**,适合重复切换的场景

  ​        3.v-if组件会有挂载/卸载过程,数据不会保留(?) v-show明显不会不保存数据

4. vue如何获取DOM?

   document.getElementById / ByClass / ByTagName      ...

   给元素添加ref , Vue2.x     this.$refs.refName      ||    Vue3.0  同样是ref , 但在setup中创建同名的空ref之后导出该ref

   ```js
   //Vue2.0
   this.$refs.formRef
   //Vue3.0
   setup(){
       const formRef = ref()  //常量名必须跟DOM中ref的值相同
       return {
           formRef
       }
   }
   ```

   

5. vue常用指令

   v-on/v-bind/v-model/v-show/v-if/v-else/v-for/v-html/v-text/v-cloak/v-once/v-pre

​       v-cloak用来防止闪烁!!!??

​       v-on绑定多个方法:

   ```js
   <input type="text" 
   v-on="{
   input:"inputMethod",
   blur:"blurMethod",
   focus:"focusMethod"
   }"
   //或者@input...@keyup ...@focus
   ...
   function inputMethod/blurMethod/focusMethod(){...}
   ```

6. v-for 为什么要使用key?

   给节点添加一个唯一标识,避免在添加或删除时出现错误

   > Usage 1:A hint for Vue's virtual DOM algorithm to identify VNodes when diffing the new list of nodes againt old lists.
   >
   > Usage 2:It can also be used to force replacement of an element/component instead of reusing it.(?)
   >
   > Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible.

​      不用key,li可能会被直接重用.例子

![img](https://upload-images.jianshu.io/upload_images/3973616-ff6a298524fd39dc.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/500/format/webp)



​        添加之后:

![img](https://upload-images.jianshu.io/upload_images/3973616-281b0c8ae857f17f.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/534/format/webp)

7. data里面为什么必须是一个函数?

   Vue2 中不return一个函数,多个组件共用同一个状态,任意组件修改了data里的值,所有组件的对应值也会被改变.       //**保护状态,确保每个组件都必须有自己的状态而不被其它组件修改**

   Vue3 中同理,不return连自己都用不了.(????笑)

8. assets和static的区别?

   相同:都是存放静态资源的目录

   不同:assets里的资源会被打包压缩格式化,之后放到static里一同上传?!(存放组件资源)

   ​         static里的资源不被打包,直接跟其它打包好的目录上传到服务器中.打包效率高,但占用资源.(非组件资源?)路径下的文件不会被webpack处理,统一在dist/static下(默认配置)

   所以: **衡量资源需不需要,可不可以压缩.需要的(如css)就放asset,要原样输出的图片/其它资源就放static**

9. delete和Vue.$delete的区别?

   delete只是将对应项设为empty/undefined(视环境而定)

   Vue.$delete更符合逻辑,会改变数组长度和数组的下标

   (???下标1直接没了?)

   ![img](https://upload-images.jianshu.io/upload_images/2367697-254e790bea2c187b.png?imageMogr2/auto-orient/strip|imageView2/2/w/721/format/webp)

10. SPA首屏优化

    (1)异步加载路由/组件/资源

    (2)不打包库文件,把库文件单独拿出来加载,然后配合webpack打包

    ```html
    <!--index.html-->
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,initial-scale=1,user-scalable=no" />
        <meta http-equiv="Pragma" content="no-cache">
        <meta http-equiv="Cache-Control" content="no-cache">
        <meta http-equiv="Expires" content="0">
        <title>test</title>
        <link rel="icon" type="image/x-icon" href="/static/favicon.ico" />
        <link rel="stylesheet" href="/static/common/css/base.css">
      </head>
      <body style="margin:0;background:#f2f2f2;">
      <script src="/static/common/js/polyfill.min.js"></script>
      <!--vue-->
      <script src="/static/common/js/vue.min.js"></script>
      <!--vue-router-->
      <script src="/static/common/js/vue-router.min.js"></script>
      <!--axios-->
      <script src="/static/common/js/axios.min.js"></script>
      <!--element-ui-->
      <link href="/static/common/js/element-ui/lib/theme-chalk/index.css"          rel="stylesheet">
      <script src="/static/common/js/element-ui/lib/index.js"></script>
      <!--echarts-->
      <script src="/static/common/js/echarts.min.js"></script>
        <div id="app"></div>
        <!-- built files will be auto injected -->
      </body>
    </html>
    
    ```

    ```js
    //webpack.base.conf.js
    externals: {
        'element-ui': 'ELEMENT',
        'vue': 'Vue',
        'axios': 'axios',
        'echarts': 'echarts',
        'vue-router': 'VueRouter'
      },
    ```

    (不会用不了吗?)

    (3) 添加loading效果

    (4) 单独首页用服务器渲染(nuxt)

