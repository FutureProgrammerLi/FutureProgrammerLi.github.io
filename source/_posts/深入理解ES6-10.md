---
title: 深入理解ES6-10
date: 2020-01-07 12:16:44
tags: 
- Javascript
- 深入理解ES6
excerpt: ES6的数组
categories: 
- 书本
---
# 深入理解ES6第十章 数组
问题引入:
```js
var arr = new Array(2); //长度为2的,undefined*2的数组
var arr1 = new Array("2"); //长度为1的，arr1[0]=2的数组
var arr2 = new Array(2,"3");//长度为2的,arr2[0]=2,arr2[1]="3"的数组
```
### 新方法 Array.of()
传入的参数`必然成为数组的元素`,而`不再可以创建指定长度的数组`.
### Array.from(arguments,function(){},[this指向])
第一个参数是需要变为数组的类数组,第二个是类似Filter的函数,第三个是修改this的指向.
```js
let helper = {
    diff:1,
    add(value){
        return value+1
    }
}
function translate(){
    return Array.from(arguments,helper.add,helper)  //因为add方法里用了this,所以需要修改this的指向
}
let numbers = translate([1,2,3])
console.log(numbers) //[2,3,4]
```

### find()和findIndex()
之前的indexOf每次只能查找一个值.
接受两个参数,一个回调函数和可选参数,用于指定回调函数中this的值(跟filter差不多?)
```js
numbers.find(value=>value>30)  //返回numbers数组里大于30的值
```
?和indexOf的区别是能否返回符合条件的,`第一个值或该值的索引`.indexOf只能是索引?

### fill()
接受3个参数,后两个可选
将数组填充成某个元素,从某个位置开始(包括该位置)填充该元素,到某个位置结束不填充该元素(不包括该索引)
```js
var arr = [2,3,4,5,6]
arr.fill(2)    //[2,2,2,2,2]
//*会修改原数组,所以不能连续调用fill*
arr.fill(2,3)  //[2,3,4,2,2]
arr.fill(2,1,3) //[2,2,2,5,6]
```

## copyWithin()
接受三个参数,都是索引值
开始粘贴的索引值,开始复制的索引值,当索引值为x的时候停止复制
```js
var arr2 = [2,3,4,5,6];
console.log(arr2.copyWithin(2,1,3)) //[23436]? [23346]
```

## 定型数组   new ArrayBuffer(length) 参数是长度,注意区别于Array.of(ele1,ele2)的参数即元素
*是一种用于处理数值类型数据的专用数组,将任何数字转换为一个包含数字比特的数组*
类型: int8,uint8,int16,uint16,int32,unit32,float32,float64
*根基:数组缓冲区,就是数组本身*
*操作根基的工具:视图*
```js
let buffer = new ArrayBuffer(10),
    view = new DataView(buffer)  //绑定需要操作的数组缓冲区
    view2 = new DataView(buffer,5,2) //从索引值5开始的两个比特单位
```
视图信息:
1. buffer    操作的是哪个缓冲区
2. byteOffset  偏移量,默认是0
3. byteLength  可操作的缓冲区的长度

`读取,写入数据`
getInt8(byteOffset,littleEndian)     
setInt8(byteOffset,value,littleEndian)
方法名根据对应类型修改, 参数的含义都是相同的.

*视图是独立的. 数据就在那存着,就看你用什么操作*
```js
let buffer = new ArrayBuffer(2),
    view = new DataView(buffer)
view.setInt8(0,5)     //索引值,元素值
view.setInt8(1,-1)
console.log(view.getInt16(0))
console.log(view.getInt8(0))
console.log(view.getInt8(1))
```

### 定型数组是视图,所以数组缓冲区还是要另外创建.
创建定型数组的三种方法
1. let view = new Int8Array(buffer)
2. let view2 = new Int8Array(2)
3. let ints1 = new Int16Array([25,50]),
   view3 = new Int32Array(ints1)
*只是创建视图时传入的参数不一样*
第一种缓冲区是已经创建好的,第二种根据指定长度创建缓冲区,第三种是在已有视图上,作为参数传给另一种类型的定型数组.

### 定型数组和普通数组的同与不同
`相同:`
可访问length属性,copyWithin,map,find等等方法
迭代器相同
Int16Array.of()和Int16Array.from()方法也是有的.
`不同:`
定型数组不是普通数组,不可用instanceof或者Array.isArray()来判定.
*length不可修改*,不能为其添加元素.
无效的值会用0来代替.如将字符串放入定型数组中,值会变0
concat,shitf,pop等等需要修改定型数组长度的方法都没有.

特有方法:set()和subarray()
set接受两个参数,1是需要设置的数组元素,是个数组. 2是需要插入的位置
```js
let init = new Int16Array(4)
	init.set([25,50])
	init.set([75,100],2) 
    //init.set([75,100150],2) //只是没有150还是连75,100都没有了?直接报错,source is too large
	console.log(init.toString()) [25,50,75,100]
```





